C:\Users\Nico\Desktop\Project\Digi-Sketch\programma\xcez1.xsf 
C:\Users\Nico\Desktop\Project\Digi-Sketch\programma\xcez1.inc 
       1       1   00000                  ;*******************************************************************************
       2       2   00000                  ;
       3       3   00000                  ; xcez1.inc is the registerfile/driver package for the XC888 micrcontroller from Infineon.
       4       4   00000                  ;
       5       5   00000                  ; The file contains drivers for various hardware and math applications.
       6       6   00000                  ; In addition all register declarations are added.
       7       7   00000                  ;
       8       8   00000                  ; WARNING:!!!!!!!
       9       9   00000                  ; INCLUDE THIS FILE AT THE END OF THE USER PROGRAM
      10      10   00000                  ;
      11      11   00000                  ; Written by Roggemans M. (MGM) 07/2011 v0.0
      12      12   00000                  ;
      13      13   00000                  ;*******************************************************************************
      14      14   00000                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
      15      15   00000                  ;
      16      16   00000                  ; xcez is een board package driver voor het XC888 SBC bord van MGM/dp.
      17      17   00000                  ;
      18      18   00000                  ; De driver bevat subroutines die toelaten de hardware van het SBC bord op een
      19      19   00000                  ; eenvoudige manier te gebruiken:
      20      20   00000                  ;
      21      21   00000                  ; standaard I/O:
      22      22   00000                  ;      initdipswitch        klaar zetten poort 4 voor gebruik met de dipswitch
      23      23   00000                  ;      initftoetsen         klaar zetten 4 functieschakelaars onderaan scherm
      24      24   00000                  ;      initleds             klaar zetten LED's als outputs
      25      25   00000                  ;
      26      26   00000                  ; I2C interface (minimale interface op 100kbit/s) enkel master mode!!
      27      27   00000                  ;      initiic              klaar zetten iic interface
      28      28   00000                  ;      iicstart             genereren van een startconditie op iic poort
      29      29   00000                  ;      iicstop              genereren stop conditie op iic poort
      30      30   00000                  ;      iicinbyteack         lezen van 1 byte met ack (accu=output)
      31      31   00000                  ;      iicinbytenack        lezen van 1 byte met nack (accu=output)
      32      32   00000                  ;      iicoutbyte           schrijven van 1 byte (accu=input, c=waarde ack bit slave)
      33      33   00000                  ;
      34      34   00000                  ; LCD interace
      35      35   00000                  ;      initlcd              klaar zetten LCD voor gebruik (incl i2c init)
      36      36   00000                  ;      lcdoutchar           schrijven van ascii code (accu=input)
      37      37   00000                  ;      lcdoutbyte           schrijven hex waarde accu naar LCD
      38      38   00000                  ;      lcdoutnib            afdrukken 4 laagste bits accu op LCD
      39      39   00000                  ;      lcdoutmsga           afdrukken ascii string @dptr, tot 000h code
      40      40   00000                  ;      lcdlighton           backlight aan
      41      41   00000                  ;      lcdlightoff          backlight uit
      42      42   00000                  ;      lcdbuzon             buzzer aan
      43      43   00000                  ;      lcdbuzof             buzzer uit
      44      44   00000                  ;
      45      45   00000                  ; Seriële interface (via USB stekker!!)
      46      46   00000                  ;      initsio              klaar zetten seriële poort 9600 baud
      47      47   00000                  ;      siooutchar           afdrukken ascii code (accu=input)
      48      48   00000                  ;      siooutbyte           afdrkken getal in accu
      49      49   00000                  ;      siooutnib            afdrukken 4 laagste bits accu
      50      50   00000                  ;      siooutmsga           afdrukken ascii string @dptr tot 000h code
      51      51   00000                  ;      sioinchar            inlezen van 1 ascii code in de accu
      52      52   00000                  ;      sioinbufa            inlezen van ascii buffer vanaf adres strtbuf, max 20h karakters!
      53      53   00000                  ;
      54      54   00000                  ; ADC
      55      55   00000                  ;      initadc              klaar zetten ADC voor minimaal gebruik
      56      56   00000                  ;      adclm335             uitlezen lm35 (a-b) bevat resultaat
      57      57   00000                  ;      adcpotmeter          uitlezen van de potmeter (a-b) bevat resultaat
      58      58   00000                  ;
      59      59   00000                  ; Arithmetic:
      60      60   00000                  ;      mul16                vermenigvuldigen 2 16 bit getallen
      61      61   00000                  ;      mul32                vermenigvuldigen 2 32 bit getallen
      62      62   00000                  ;      div16                delen 2 16 bit getallen
      63      63   00000                  ;      div32                delen 2 32 bit getallen
      64      64   00000                  ;      add16                optellen 2 16 bit getallen
      65      65   00000                  ;      add32                optellen 2 32 bit getallen
      66      66   00000                  ;      sub16                verschil 2 16 bit getallen
      67      67   00000                  ;      sub32                verschil 2 32 bit getallen
      68      68   00000                  ;      hexbcd8              omvormen 8 bit hex naar bcd
      69      69   00000                  ;      hexbcd16             omvormen 16 bit hex naar bcd
      70      70   00000                  ;      bcdhex8              omvormen 8 bit bcd naar hex
      71      71   00000                  ;      bcdhex16             omvormen 16 bit bcd naar hex
      72      72   00000                  ;
      73      73   00000                  ; Diverse
      74      74   00000                  ;      delaya0k05s          tijdsvertraging (waarde in accu)*0,05s
      75      75   00000                  ;      delay1ms             tijdsverraging 1 milliseconde
      76      76   00000                  ;      delay10us            tijdsvertraging 10 microseconde
      77      77   00000                  ;      XCsw2xtal            overschakelen rc naar kristal (Pauwels Danny)
      78      78   00000                  ;	mapregs 		selecteer de SFR's in de mapped area
      79      79   00000                  ;	nomapregs            selecteer de SFR's in de non-mapped area
      80      80   00000                  ;
      81      81   00000                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
      82      82   00000                  ; LET OP!!!!
      83      83   00000                  ; Voor je de routines gebruikt ga in de betreffende header na wat het registergebruik is,
      84      84   00000                  ; hoe parameters doorgegeven worden, en wat de beperkingen zijn!!
      85      85   00000                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
      86      86   00000                  ;
      87      87   00000                  ; Geschreven door Roggemans M. (MGM) xcbpd0.inc   07/2010
      88      88   00000                  ;
      89      89   00000                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
      90      90   00000                  
      91      91   00000                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
      92      92   00000                  ;
      93      93   00000                  ; initdipswitch      is een subroutine die de pinnen van poort 4 insteld als input met
      94      94   00000                  ; pull-up weerstanden ingeschakeld. Hierdoor kunnen schakelaars gebruikt worden naar
      95      95   00000                  ; massa zonder extra weerstanden.
      96      96   00000                  ;
      97      97   00000                  ; Gebruikt geen registers
      98      98   00000                  ;
      99      99   00000                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     100     100   00000                  
     101     101   00000 C08F             initdipswitch:push   syscon0              ;juiste map selecteren
     102     102   00002 758F04                         mov    syscon0,#004h
     103     103   00005 C0B2                           push   port_page            ;tijdelijk bewaren zodat we dat kunnen herstellen
     104     104   00007 75B201                         mov    port_page,#001h      ;selecteer poort page 1
     105     105   0000A 75C8FF                         mov    p4_pudsel,#0ffh      ;selecteer pull_up device
     106     106   0000D 75C9FF                         mov    p4_puden,#0ffh       ;selectie inschakelen
     107     107   00010 75B200                         mov    port_page,#000h      ;pagina 0 selecteren
     108     108   00013 75C900                         mov    p4_dir,#000h         ;poort 4 als input schakelen
     109     109   00016 D0B2                           pop    port_page            ;herstellen in oorspronkelijke staat
     110     110   00018 D08F                           pop    syscon0              ;pagina terug herstellen
     111     111   0001A 22                             ret
     112     112   0001B                  
     113     113   0001B                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     114     114   0001B                  ;
     115     115   0001B                  ; initftoetsen       is een routine die de 4 functieschakelaars onder het LCD display
     116     116   0001B                  ; klaar zet voor gebruik met een schakelaar naar massa. De overige 4 pinnen van poort
     117     117   0001B                  ; 2 behouden hun originele instelling.
     118     118   0001B                  ;
     119     119   0001B                  ; Gebruikt geen registers
     120     120   0001B                  ;
     121     121   0001B                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     122     122   0001B                  
     123     123   0001B C08F             initftoetsen: push   syscon0              ;juiste map selecteren
     124     124   0001D 758F04                         mov    syscon0,#004h
     125     125   00020 C0B2                           push   port_page            ;tijdelijk bewaren zodat we dat kunnen herstellen
     126     126   00022 75B201                         mov    port_page,#001h      ;selecteer poort page 1
     127     127   00025 43A00F                         orl    p2_pudsel,#00fh      ;selecteer pull_up device (onderste 4 pinnen)
     128     128   00028 43A10F                         orl    p2_puden,#00fh       ;selectie inschakelen (onderste 4 pinnen)
     129     129   0002B 75B200                         mov    port_page,#000h      ;pagina 0 selecteren
     130     130   0002E 53A1F0                         anl    p2_dir,#0f0h         ;input drivers activeren (onderste 4 pinnen)
     131     131   00031 D0B2                           pop    port_page            ;herstellen in oorspronkelijke staat
     132     132   00033 D08F                           pop    syscon0              ;pagina terug herstellen
     133     133   00035 22                             ret
     134     134   00036                  
     135     135   00036                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     136     136   00036                  ;
     137     137   00036                  ; initleds           is een routine die de poort 3 als output schakeld. De LED's
     138     138   00036                  ; worden gedoofd (actief laag om ze te laden branden).
     139     139   00036                  ;
     140     140   00036                  ; Gebruikt geen registers
     141     141   00036                  ;
     142     142   00036                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     143     143   00036                  
     144     144   00036                  
     145     145   00036 C08F             initleds:     push   syscon0              ;juiste map selecteren
     146     146   00038 758F04                         mov    syscon0,#004h
     147     147   0003B C0B2                           push   port_page            ;tijdelijk bewaren zodat we dat kunnen herstellen
     148     148   0003D 75B200                         mov    port_page,#000h      ;selecteer poort page 0
     149     149   00040 75B1FF                         mov    p3_dir,#0ffh         ;poort 3 als output schakelen
     150     150   00043 D0B2                           pop    port_page            ;herstellen in oorspronkelijke staat
     151     151   00045 D08F                           pop    syscon0              ;pagina terug herstellen
     152     152   00047 22                             ret
     153     153   00048                  
     154     154   00048                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     155     155   00048                  ;
     156     156   00048                  ; initiic            is een subroutine die de pinnen p0.7 (sda) en p0.3 (scl) klaar zet
     157     157   00048                  ; voor gebruik als IIC bus. De andere poortpinnen worden niet aangepast
     158     158   00048                  ; scl wordt als oc output geschakeld met data waarde 1 (bus in rust)
     159     159   00048                  ; sda wordt als input geschakeld
     160     160   00048                  ;
     161     161   00048                  ; LET OP!!
     162     162   00048                  ; Dit is een IIC bus met beperkte mogelijkheden:
     163     163   00048                  ; -vaste communicatiesnleheid van 100kbit/s
     164     164   00048                  ; -enkel master mode
     165     165   00048                  ; -enkel 7 bit adressering
     166     166   00048                  ; -geen klok stretching
     167     167   00048                  ;
     168     168   00048                  ; Gebruikt geen registers
     169     169   00048                  ;
     170     170   00048                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     171     171   00048                  
     172     172   00048                  sda           bit    p0_data.7            ;pin gebruikt als sda
     173     173   00048                  scl           bit    p0_data.3            ;pin gebruikt als scl
     174     174   00048                  sdaout        equ    10000000b            ;masker om sda als output te schakelen
     175     175   00048                  sdain         equ    01111111b            ;masker om sda als input te schakelen
     176     176   00048                  
     177     177   00048 C08F             initiic:      push   syscon0              ;juiste map selecteren
     178     178   0004A 758F04                         mov    syscon0,#004h
     179     179   0004D C0B2                           push   port_page
     180     180   0004F 75B200                         mov    port_page,#000h      ;pagina 0 selecteren
     181     181   00052 D287                           setb   sda                  ;data op 1 zetten (ruststand iic)
     182     182   00054 D283                           setb   scl                  ;klok op 1 zetten (ruststand iic)
     183     183   00056 75B203                         mov    port_page,#003h      ;p0_od toegankelijk maken
     184     184   00059 D283                           setb   scl                  ;klok werkt als od
     185     185   0005B D287                           setb   sda                  ;sda werkt als od
     186     186   0005D 75B200                         mov    port_page,#000h      ;terug pagina 0 selecteren
     187     187   00060 438608                         orl    p0_dir,#00001000b    ;scl als output selecteren
     188     188   00063 53867F                         anl    p0_dir,#01111111b    ;sda als input selecteren
     189     189   00066 D0B2                           pop    port_page            ;pagina herstellen
     190     190   00068 D08F                           pop    syscon0              ;map herstellen
     191     191   0006A 22                             ret
     192     192   0006B                  
     193     193   0006B                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     194     194   0006B                  ;
     195     195   0006B                  ; iicstart           is een subroutine die op de iic bus een start conditie opwekt.
     196     196   0006B                  ; Bij de start conditie wordt eerst de scl laag gemaakt, dan de sda. Om de bittijd
     197     197   0006B                  ; te garanderen volgt er een delay van 10us
     198     198   0006B                  ;
     199     199   0006B                  ; Gebruikt geen registers
     200     200   0006B                  ;
     201     201   0006B                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     202     202   0006B                  
     203     203   0006B C08F             iicstart:     push   syscon0              ;map bewaren
     204     204   0006D 758F04                         mov    syscon0,#004h        ;hoofdmap selecteren
     205     205   00070 C0B2                           push   port_page            ;pagina bewaren
     206     206   00072 75B200                         mov    port_page,#000h      ;hier zit alles wat we nodig hebben
     207     207   00075 D283                           setb   scl                  ;zeker zijn dat we vanuit ruststand vertrekken
     208     208   00077 D287                           setb   sda                  ;idem
     209     209   00079 438680                         orl    p0_dir,#sdaout       ;pin als output schakelen
     210     210   0007C 12016C                         lcall  delay10us            ;
     211     211   0007F C287                           clr    sda                  ;data laag
     212     212   00081 12016C                         lcall  delay10us
     213     213   00084 C283                           clr    scl                  ;dan klok laag
     214     214   00086 12016C                         lcall  delay10us            ;bit lang genoeg maken
     215     215   00089 D0B2                           pop    port_page            ;registers herstellen
     216     216   0008B D08F                           pop    syscon0
     217     217   0008D 22                             ret
     218     218   0008E                  
     219     219   0008E                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     220     220   0008E                  ;
     221     221   0008E                  ; iicstop            is een subroutine die een stop conditie op de IIC bus plaatst.
     222     222   0008E                  ;
     223     223   0008E                  ; Gebruikt geen registers
     224     224   0008E                  ;
     225     225   0008E                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     226     226   0008E                  
     227     227   0008E C08F             iicstop:      push   syscon0              ;map bewaren
     228     228   00090 758F04                         mov    syscon0,#004h        ;hoofd map selecteren
     229     229   00093 C0B2                           push   port_page            ;pagina bewaren
     230     230   00095 75B200                         mov    port_page,#000h      ;hier zit alles wat we nodig hebben
     231     231   00098 438680                         orl    p0_dir,#sdaout       ;pin als output schakelen
     232     232   0009B C287                           clr    sda                  ;data naar omlaag
     233     233   0009D 12016C                         lcall  delay10us
     234     234   000A0 D283                           setb   scl                  ;klok naar 1
     235     235   000A2 12016C                         lcall  delay10us            ;wachten
     236     236   000A5 D287                           setb   sda                  ;idem data
     237     237   000A7 12016C                         lcall  delay10us            ;
     238     238   000AA 53867F                         anl    p0_dir,#sdain        ;pin terug als input schakelen
     239     239   000AD D0B2                           pop    port_page            ;registers herstellen
     240     240   000AF D08F                           pop    syscon0
     241     241   000B1 22                             ret
     242     242   000B2                  
     243     243   000B2                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     244     244   000B2                  ;
     245     245   000B2                  ; iicoutbyte         is een subroutine die de data uit de accu naar buiten stuurt op
     246     246   000B2                  ; de iic bus. In totaal worden er 8 bits verzonden. Daarna wordt een negende klokpuls
     247     247   000B2                  ; gegenereerd om de ack bit in te lezen. Die wordt doorgegeven via de c vlag
     248     248   000B2                  ;
     249     249   000B2                  ; Gebruikt:
     250     250   000B2                  ;      a=inbut te verzenden byte (accu wordt niet vernietigd)
     251     251   000B2                  ;      cy=ack bit vanuit de slave
     252     252   000B2                  ;
     253     253   000B2                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     254     254   000B2                  
     255     255   000B2 C0E0             iicoutbyte:   push   acc                  ;straks alles herstellen
     256     256   000B4 C0F0                           push   b                    ;gebruikt als loopcounter
     257     257   000B6 C08F                           push   syscon0              ;map juist zetten
     258     258   000B8 758F04                         mov    syscon0,#004h        ;hofdmap selecteren
     259     259   000BB C0B2                           push   port_page            ;poort pagina bewaren
     260     260   000BD 75B200                         mov    port_page,#000h      ;basispagina selecteren
     261     261   000C0 75F008                         mov    b,#008h              ;wordt gebruikt als loopcounter
     262     262   000C3 438680                         orl    p0_dir,#sdaout       ;poortpin als output zetten
     263     263   000C6 33               iicoutbyte1:  rlc    a                    ;hier gaan we dan (bit per bit naar buiten)
     264     264   000C7 9287                           mov    sda,c                ;op pin
     265     265   000C9 12016C                         lcall  delay10us            ;wachten
     266     266   000CC D283                           setb   scl                  ;puls genereren
     267     267   000CE 12016C                         lcall  delay10us            ;ook hier wat tijd laten
     268     268   000D1 C283                           clr    scl                  ;klok terug laag maken
     269     269   000D3 D5F0F0                         djnz   b,iicoutbyte1        ;herhaal 8 keer
     270     270   000D6                  
     271     271   000D6                  ; de 8 bits zijn weg, nu de ack binnen nemen.
     272     272   000D6                  
     273     273   000D6 53867F                         anl    p0_dir,#sdain        ;pin als input schakelen
     274     274   000D9 12016C                         lcall  delay10us            ;wachten tot data zeker beschikbaar
     275     275   000DC D283                           setb   scl                  ;puls terug hoog
     276     276   000DE A287                           mov    c,sda                ;inlezen en naar carry
     277     277   000E0 12016C                         lcall  delay10us
     278     278   000E3 C283                           clr    scl                  ;klok blijft laag achter
     279     279   000E5 D0B2                           pop    port_page
     280     280   000E7 D08F                           pop    syscon0
     281     281   000E9 D0F0                           pop    b
     282     282   000EB D0E0                           pop    acc
     283     283   000ED 22                             ret
     284     284   000EE                  
     285     285   000EE                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     286     286   000EE                  ;
     287     287   000EE                  ; iicinbyteack       is een subroutine die 1 byte inleest en als negendebit een ack
     288     288   000EE                  ; naar de slave zal zenden. De accu wordt gebruikt om de ingelezen data door te geven.
     289     289   000EE                  ;
     290     290   000EE                  ; Gebruikt:
     291     291   000EE                  ;      -de accu als output
     292     292   000EE                  ;
     293     293   000EE                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     294     294   000EE                  
     295     295   000EE C08F             iicinbyteack: push   syscon0              ;huidige map bewaren
     296     296   000F0 758F04                         mov    syscon0,#004h        ;basispagina kiezen
     297     297   000F3 C0B2                           push   port_page            ;pagina bewaren
     298     298   000F5 75B200                         mov    port_page,#000h      ;deze hebben we nodig
     299     299   000F8 C0F0                           push   b                    ;wordt gebruikt als loopcounter
     300     300   000FA C0D0                           push   psw                  ;vlaggen bewaren
     301     301   000FC 75F008                         mov    b,#008h              ;loopcounter laden
     302     302   000FF 53867F                         anl    p0_dir,#sdain        ;pin als input schakelen
     303     303   00102 12016C           iicinbyteack1:lcall  delay10us
     304     304   00105 D283                           setb   scl                  ;klok hoog
     305     305   00107 A287                           mov    c,sda                ;pin inlezen
     306     306   00109 33                             rlc    a                    ;in accu shiften
     307     307   0010A 12016C                         lcall  delay10us
     308     308   0010D C283                           clr    scl                  ;klok terug laag
     309     309   0010F D5F0F0                         djnz   b,iicinbyteack1
     310     310   00112 438680                         orl    p0_dir,#sdaout       ;pin als output schakelen
     311     311   00115 C287                           clr    sda                  ;ack genereren
     312     312   00117 12016C                         lcall  delay10us
     313     313   0011A D283                           setb   scl
     314     314   0011C 12016C                         lcall  delay10us
     315     315   0011F C283                           clr    scl
     316     316   00121 53867F                         anl    p0_dir,#sdain        ;pin terug als input schakelen
     317     317   00124 D0D0                           pop    psw                  ;registers herstellen
     318     318   00126 D0F0                           pop    b
     319     319   00128 D0B2                           pop    port_page
     320     320   0012A D08F                           pop    syscon0
     321     321   0012C 22                             ret
     322     322   0012D                  
     323     323   0012D                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     324     324   0012D                  ;
     325     325   0012D                  ; iicinbytenack      is een subroutine die 1 byte inleest en als negendebit een nack
     326     326   0012D                  ; naar de slave zal zenden. De accu wordt gebruikt om de ingelezen data door te geven.
     327     327   0012D                  ;
     328     328   0012D                  ; Gebruikt:
     329     329   0012D                  ;      -de accu als output
     330     330   0012D                  ;
     331     331   0012D                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     332     332   0012D                  
     333     333   0012D C08F             iicinbytenack:push   syscon0              ;huidige map bewaren
     334     334   0012F 758F04                         mov    syscon0,#004h        ;basispagina kiezen
     335     335   00132 C0B2                           push   port_page            ;pagina bewaren
     336     336   00134 75B200                         mov    port_page,#000h      ;deze hebben we nodig
     337     337   00137 C0F0                           push   b                    ;wordt gebruikt als loopcounter
     338     338   00139 C0D0                           push   psw                  ;vlaggen bewaren
     339     339   0013B 75F008                         mov    b,#008h              ;loopcounter laden
     340     340   0013E 53867F                         anl    p0_dir,#sdain        ;pin als input schakelen
     341     341   00141 12016C           iicinbytenack1:lcall  delay10us
     342     342   00144 D283                           setb   scl                  ;klok hoog
     343     343   00146 A287                           mov    c,sda                ;pin inlezen
     344     344   00148 33                             rlc    a                    ;in accu shiften
     345     345   00149 12016C                         lcall  delay10us
     346     346   0014C C283                           clr    scl                  ;klok terug laag
     347     347   0014E D5F0F0                         djnz   b,iicinbytenack1     ;8 keer herhalen
     348     348   00151 438680                         orl    p0_dir,#sdaout       ;pin als output schakelen
     349     349   00154 D287                           setb   sda                  ;nack genereren
     350     350   00156 12016C                         lcall  delay10us
     351     351   00159 D283                           setb   scl
     352     352   0015B 12016C                         lcall  delay10us
     353     353   0015E C283                           clr    scl
     354     354   00160 53867F                         anl    p0_dir,#sdain        ;pin terug als input schakelen
     355     355   00163 D0D0                           pop    psw                  ;registers herstellen
     356     356   00165 D0F0                           pop    b
     357     357   00167 D0B2                           pop    port_page
     358     358   00169 D08F                           pop    syscon0
     359     359   0016B 22                             ret
     360     360   0016C                  
     361     361   0016C                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     362     362   0016C                  ;
     363     363   0016C                  ; delay10us          is een tijdsvertraging van 10us. Wordt gebruikt om de IIC bus
     364     364   0016C                  ; te vertragen tot een maximale snelheid van 100kbit/s In realiteit zal de bussnelheid
     365     365   0016C                  ; lager liggen. We houden immers geen rekening met de uitvoeringstijd van de routines,
     366     366   0016C                  ; en de gebruikte delay is dubbel zo lang als stikt nodig (5us volstaat).
     367     367   0016C                  ;
     368     368   0016C                  ; Gebruikt geen registers
     369     369   0016C                  ;
     370     370   0016C                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     371     371   0016C                  
     372     372   0016C C0E0             delay10us:    push   acc                  ;8*42ns=330ns
     373     373   0016E C0D0                           push   psw                  ;8*42ns=330ns
     374     374   00170 75E01A                         mov    acc,#01ah            ;420ns
     375     375   00173 D5E0FD                         djnz   acc,$                ;420ns*aantal keer doorlopen
     376     376   00176 D0D0                           pop    psw                  ;8*42ns=330ns
     377     377   00178 D0E0                           pop    acc                  ;8*42ns=330ns
     378     378   0017A 22                             ret                         ;165ns
     379     379   0017B                  
     380     380   0017B                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     381     381   0017B                  ;
     382     382   0017B                  ; delaya0k05s        is een tijdsvertraging van 0,05s maal het getal in de accu
     383     383   0017B                  ;
     384     384   0017B                  ; Gebruikt geen registers
     385     385   0017B                  ;
     386     386   0017B                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     387     387   0017B                  
     388     388   0017B C0E0             delaya0k05s:  push   acc                  ;registers bewaren
     389     389   0017D C0D0                           push   psw
     390     390   0017F C0F0                           push   b
     391     391   00181 75F032           delaya0k05s2: mov    b,#050               ;loopcounter
     392     392   00184 120194           delaya0k05s1: lcall  delay1ms
     393     393   00187 D5F0FA                         djnz   b,delaya0k05s1
     394     394   0018A D5E0F4                         djnz   acc,delaya0k05s2
     395     395   0018D D0F0                           pop    b                    ;registers herstellen
     396     396   0018F D0D0                           pop    psw
     397     397   00191 D0E0                           pop    acc
     398     398   00193 22                             ret
     399     399   00194                  
     400     400   00194                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     401     401   00194                  ;
     402     402   00194                  ; Delay1ms           is een tijdsvertraging van 1 ms.
     403     403   00194                  ;
     404     404   00194                  ; Gebruikt geen registers
     405     405   00194                  ;
     406     406   00194                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     407     407   00194                  
     408     408   00194 C0E0             delay1ms:     push   acc                  ;8*42ns=330ns
     409     409   00196 C0D0                           push   psw                  ;8*42ns=330ns
     410     410   00198 75E064                         mov    acc,#100             ;420ns
     411     411   0019B 12016C           delay1ms1:    lcall  delay10us            ;10us
     412     412   0019E D5E0FA                         djnz   acc,delay1ms1        ;420ns*aantal keer doorlopen
     413     413   001A1 D0D0                           pop    psw                  ;8*42ns=330ns
     414     414   001A3 D0E0                           pop    acc                  ;8*42ns=330ns
     415     415   001A5 22                             ret                         ;165ns
     416     416   001A6                  
     417     417   001A6                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     418     418   001A6                  ;
     419     419   001A6                  ; Dit is het LCD driver gedeelte. Het is gebaseerd op de LCD driver van MGM van 1994.
     420     420   001A6                  ; De driver is aangepast voor het XC888 SBC en kan gebruikt worden met standaard
     421     421   001A6                  ; alfanumerische display's. Het bord wordt gebruikt met een 2*20 of een 4*20 karakter
     422     422   001A6                  ; display. De basisroutines zijn bruikbaar voor alle types schermen (de
     423     423   001A6                  ; gebruiker moet dan wel zelf wakker liggen over cursorrouting).
     424     424   001A6                  ; De hogere routines gaan er van uit dat we een 4*20 karakter display gebruiken.
     425     425   001A6                  ; Parameters worden doorgegeven via de accu, b register, dptr of r0.
     426     426   001A6                  ; De routines gebruiken geen registers. Alle timing is voorzien voor een XC888 op
     427     427   001A6                  ; maximale snelheid. Loopt de controller trager, dan zullen de tijdsvertragingen te
     428     428   001A6                  ; lang zijn. De driver zal automatisch de IIC interface initialiseren omdat die gebruikt
     429     429   001A6                  ; wordt om de LCD te bereiken. Deze routines zijn NIET bruikbaar op andere hadware
     430     430   001A6                  ; systemen!!!!
     431     431   001A6                  ;
     432     432   001A6                  ; GESCHREVEN OP 02/1994 DOOR MARC ROGGEMANS (MGM) als lcd.drv
     433     433   001A6                  ;      -aangepast door Roggemans Marc (MGM) op 11/2004 voor ADuC800 kaart als
     434     434   001A6                  ;       aduclcd0.inc
     435     435   001A6                  ;      -aangepast door Roggemans Marc (MGM) op 11/11/2004
     436     436   001A6                  ;       aduclcd1.inc
     437     437   001A6                  ;      -aangepast door Roggemans Marc (MGM) op 07/2010 voor XC888 SBC met IIC bus
     438     438   001A6                  ;
     439     439   001A6                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     440     440   001A6                  
     441     441   001A6                  e             bit    b.1                  ;enable
     442     442   001A6                  rs            bit    b.0                  ;register select
     443     443   001A6                  backlight     bit    b.6                  ;bit waar backlight op zit
     444     444   001A6                  buzzer        bit    b.7                  ;bit waar buzzer op zit
     445     445   001A6                  
     446     446   001A6                  lcdport       EQU    b                    ;b regsiter wordt gebruikt als dummy poort
     447     447   001A6                  
     448     448   001A6                  cleardisp     EQU    001H                 ;LEEG MAKEN VAN HET SCHERM
     449     449   001A6                  cursathom     EQU    002H                 ;CURSOR OP DE EERSTE PLAATS ZETTEN
     450     450   001A6                  
     451     451   001A6                  entrymode     EQU    00000110B            ;CURSOR NAAR RECHTS, SCHERM VAST
     452     452   001A6                  displayon     EQU    00000001B            ;HOMEN EN CLEAR CURSOR
     453     453   001A6                  displayof     EQU    00001000B            ;DISPLAY OFF, CURSOR OFF
     454     454   001A6                  cursoroff     EQU    00001100B            ;DISPLAY ON ZONDER CURSOR
     455     455   001A6                  cursoronb     EQU    00001111B            ;CURSOR ON AND BLINK
     456     456   001A6                  cursoronn     EQU    00001110B            ;CURSOR ON NO BLINK
     457     457   001A6                  functions     EQU    00101000B            ;INTERFACE LENGTE EN KARAKTER FONT
     458     458   001A6                  cgram         EQU    01000000B            ;SELECTIE KARAKTER GENERATOR RAM
     459     459   001A6                  ddram         EQU    10000000B            ;SELECTIE DATA DISPLAY RAM
     460     460   001A6                  
     461     461   001A6                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     462     462   001A6                  ;
     463     463   001A6                  ; initlcd     zal het scherm resetten en initialiseren voor gebruik via een 4
     464     464   001A6                  ; bit bus. De routine zet het scherm klaar voor normaal gebruik: ingave van
     465     465   001A6                  ; links naar rechts zonder display shift, normale karakterfont. De kursor staat
     466     466   001A6                  ; aan als een knipperend lijntje onderaan de regel. Het scherm is leeg.
     467     467   001A6                  ;
     468     468   001A6                  ; registergebruik: geen
     469     469   001A6                  ;
     470     470   001A6                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     471     471   001A6                  
     472     472   001A6 C0E0             initlcd:      push   acc                  ;registers op stack plaatsen
     473     473   001A8 C0D0                           push   psw
     474     474   001AA C0F0                           push   b                    ;wordt gebruikt als dummy lcd poort
     475     475   001AC 120048                         lcall  initiic              ;vermits de LCD gebruikt wordt via een IIC bus
     476     476   001AF 75F0FD                         mov    lcdport,#11111101b   ;poort in uitgangstoestand zetten
     477     477   001B2                                                            ;buzzer en baklight worden nu op 1 gezet
     478     478   001B2 12034A                         lcall  porttolcd            ;routine die de data uit b naar het scherm stuurt
     479     479   001B5 7410                           mov    a,#010h       ;bij opstarten meer dan 30ms wachten
     480     480   001B7 120343           initlcd1:     lcall  delay2ms
     481     481   001BA D5E0FA                         djnz   acc,initlcd1
     482     482   001BD 7430                           mov    a,#00110000b  ;volgende drie schrijfbeurten zijn
     483     483   001BF 120302                         lcall  outhnibc      ;een truuk om het display altijd opgestart
     484     484   001C2 120343                         lcall  delay2ms      ;te krijgen.
     485     485   001C5 7430                           mov    a,#00110000b
     486     486   001C7 120302                         lcall  outhnibc
     487     487   001CA 120343                         lcall  delay2ms
     488     488   001CD 7430                           mov    a,#00110000b
     489     489   001CF 120302                         lcall  outhnibc
     490     490   001D2 120343                         lcall  delay2ms
     491     491   001D5 7420                           mov    a,#00100000b  ;instellen 4 bit interface gebruiken
     492     492   001D7 120302                         lcall  outhnibc      ;hoge nibble naar het controleregister
     493     493   001DA 120343                         lcall  delay2ms      ;niet nodig volgens datasheet
     494     494   001DD 7428                           mov    a,#functions  ;4 bit interface, twee lijnen 5*8 dots
     495     495   001DF 1202EC                         lcall  outc          ;naar display
     496     496   001E2 120343                         lcall  delay2ms      ;is iets te lang volgens datasheet
     497     497   001E5 740F                           mov    a,#cursoronb  ;display on cursor on and blink
     498     498   001E7 1202EC                         lcall  outc
     499     499   001EA 120343                         lcall  delay2ms      ;ook deze delay is iets te lang
     500     500   001ED 7401                           mov    a,#displayon  ;clear display and home cursor
     501     501   001EF 1202EC                         lcall  outc
     502     502   001F2 120343                         lcall  delay2ms      ;deze wachttijd is bijna juist
     503     503   001F5 7406                           mov    a,#entrymode  ;display klaar zetten normaal gebruik
     504     504   001F7 1202EC                         lcall  outc
     505     505   001FA 120343                         lcall  delay2ms      ;wachten weer veel te lang
     506     506   001FD D0F0                           pop    b             ;registers terug in orde zetten
     507     507   001FF D0D0                           pop    psw
     508     508   00201 D0E0                           pop    acc
     509     509   00203 22                             ret                  ;einde van de initialisatie
     510     510   00204                  
     511     511   00204                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     512     512   00204                  ;
     513     513   00204                  ; lcdoutchar  zal de ascii code in de accu naar het lcd scherm sturen. De codes
     514     514   00204                  ; lager dan 020h worden als controlekarakters bekeken met volgende acties:
     515     515   00204                  ;      00dh   =cursor in de home positie
     516     516   00204                  ;      00ch   =form feed    =scherm leeg maken en cursor op lacatie 000h
     517     517   00204                  ;      00ah   =cursor op tweede lijn plaatsen
     518     518   00204                  ;      001h   =cursor on blink
     519     519   00204                  ;      002h   =cursor on, no blink
     520     520   00204                  ;      003h   =cursor off
     521     521   00204                  ;      080h-0ffh     =cursor plaatsen op dit adres -80h
     522     522   00204                  ;
     523     523   00204                  ; de routine gebruikt geen registers
     524     524   00204                  ;
     525     525   00204                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     526     526   00204                  
     527     527   00204                  ; we gaan eerst na of het een ascii code betreft van een symbool. Als dat zo is,
     528     528   00204                  ; dan mag de data direct naar het dataregister van het scherm.
     529     529   00204                  ; Betreft een controle karakter, dan is een andere aanpak nodig (zie verder).
     530     530   00204                  
     531     531   00204                  lcdoutchar:
     532     532   00204 C0E0             outcharlcd:   push   acc           ;registers op stack
     533     533   00206 C0D0                           push   psw
     534     534   00208 B48000                         cjne   a,#080h,outcharlcd1  ;hogere codes zijn adressen
     535     535   0020B 5046             outcharlcd1:  jnc    outcharlcd9   ;als geen carry dan is de code een address
     536     536   0020D B42000                         cjne   a,#020h,outcharlcd2  ;hogere codes zijn ascii van symbolen
     537     537   00210 503C             outcharlcd2:  jnc    outcharlcd8   ;als geen carry dan ascii code naar display
     538     538   00212                  
     539     539   00212                  ; de code in de accu is geen adres of geen geldige ascii code van een symbool.
     540     540   00212                  ; Het is dus een opdracht die we moeten uitvoeren.
     541     541   00212                  
     542     542   00212 B40C07                         cjne   a,#00ch,outcharlcd3  ;geen form feed, dan jump
     543     543   00215 7401                           mov    a,#cleardisp         ;scherm leegmaken
     544     544   00217 1202EC                         lcall  outc                 ;naar controleregister
     545     545   0021A 803A                           sjmp   outcharlcde          ;afsluiten
     546     546   0021C                  
     547     547   0021C B40107           outcharlcd3:  cjne   a,#001h,outcharlcd4  ;geen cursor on blink
     548     548   0021F 740F                           mov    a,#cursoronb         ;cursoron met blink
     549     549   00221 1202EC                         lcall  outc
     550     550   00224 8030                           sjmp   outcharlcde
     551     551   00226                  
     552     552   00226 B40207           outcharlcd4:  cjne   a,#002h,outcharlcd5  ;geen cursor on no blink
     553     553   00229 740E                           mov    a,#cursoronn         ;cursoron no blink
     554     554   0022B 1202EC                         lcall  outc
     555     555   0022E 8026                           sjmp   outcharlcde
     556     556   00230                  
     557     557   00230 B40307           outcharlcd5:  cjne   a,#003h,outcharlcd6  ;geen cursor off, dus afsluiten routine
     558     558   00233 740C                           mov    a,#cursoroff         ;cursor uitschakelen
     559     559   00235 1202EC                         lcall  outc
     560     560   00238 801C                           sjmp   outcharlcde
     561     561   0023A                  
     562     562   0023A B40D07           outcharlcd6:  cjne   a,#00dh,outcharlcd7  ;geen cursor home zonder clear scherm
     563     563   0023D 7402                           mov    a,#cursathom         ;cursor in home positie
     564     564   0023F 1202EC                         lcall  outc
     565     565   00242 8012                           sjmp   outcharlcde
     566     566   00244                  
     567     567   00244 B40A0F           outcharlcd7:  cjne   a,#00ah,outcharlcde  ;line feed gevraagd (zet cursor op
     568     568   00247                                                            ;tweede lijn
     569     569   00247 74C0                           mov    a,#0c0h
     570     570   00249 1202EC                         lcall  outc
     571     571   0024C 8008                           sjmp   outcharlcde
     572     572   0024E                  
     573     573   0024E                  ; dit label wordt uitgevoerd als de code in de accumulator een geldige ascii code
     574     574   0024E                  ; is. dit mag naar het data register.
     575     575   0024E                  
     576     576   0024E 1202B2           outcharlcd8:  lcall  outd          ;klaar
     577     577   00251 8003                           sjmp   outcharlcde   ;einde routine
     578     578   00253                  
     579     579   00253                  ; dit label wordt uitgevoerd als de code in de accu een adres is. Dit adres is
     580     580   00253                  ; eigenlijk 80 te groot. Dat komt echter goed uit als commando om een adrers te
     581     581   00253                  ; te schrijven.
     582     582   00253                  
     583     583   00253 1202EC           outcharlcd9:  lcall  outc          ;klaar
     584     584   00256 D0D0             outcharlcde:  pop    psw           ;registers herstellen
     585     585   00258 D0E0                           pop    acc
     586     586   0025A 22                             ret
     587     587   0025B                  
     588     588   0025B                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     589     589   0025B                  ;
     590     590   0025B                  ; outniblcd     zal de lage nibble omzetten in een ascii code en die afdrukken
     591     591   0025B                  ; op het lcd scherm.
     592     592   0025B                  ;
     593     593   0025B                  ; de routine gebruikt geen registers
     594     594   0025B                  ;
     595     595   0025B                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     596     596   0025B                  
     597     597   0025B                  lcdoutnib:
     598     598   0025B C0E0             outniblcd:    push   acc           ;registers op stack zetten
     599     599   0025D C0D0                           push   psw
     600     600   0025F 540F                           anl    a,#00fh       ;laagste 4 bits overhouden
     601     601   00261 2430                           add    a,#030h       ;omvormen naar ascii codes 0-9
     602     602   00263 B43A00                         cjne   a,#03ah,outniblcd1   ;als groter dan dit nog 7 bijtellen
     603     603   00266 4002             outniblcd1:   jc     outniblcde    ;als carry dan omzetting klaar
     604     604   00268 2407                           add    a,#007h       ;omvormen naar hoofdletter
     605     605   0026A 1202B2           outniblcde:   lcall  outd          ;naar het scherm
     606     606   0026D D0D0                           pop    psw
     607     607   0026F D0E0                           pop    acc
     608     608   00271 22                             ret
     609     609   00272                  
     610     610   00272                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     611     611   00272                  ;
     612     612   00272                  ; lcdoutbyte    zal de inhoud van de accu afdrukken op het lcd scherm.
     613     613   00272                  ;
     614     614   00272                  ; de routine gebruikt geen registers
     615     615   00272                  ;
     616     616   00272                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     617     617   00272                  
     618     618   00272                  lcdoutbyte:
     619     619   00272 C0E0             outbytelcd:   push   acc           ;registers op de stack zetten
     620     620   00274 C0D0                           push   psw
     621     621   00276 C4                             swap   a             ;bitjes omruilen
     622     622   00277 12025B                         lcall  outniblcd
     623     623   0027A C4                             swap   a             ;nog eens
     624     624   0027B 12025B                         lcall  outniblcd
     625     625   0027E D0D0                           pop    psw
     626     626   00280 D0E0                           pop    acc
     627     627   00282 22                             ret
     628     628   00283                  
     629     629   00283                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     630     630   00283                  ;
     631     631   00283                  ; lcddispdptr   zal de inhoud van de dptr afdrukken op het lcd scherm
     632     632   00283                  ;
     633     633   00283                  ; de routine gebruikt geen registers
     634     634   00283                  ;
     635     635   00283                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     636     636   00283                  
     637     637   00283                  lcddispdptr:
     638     638   00283 C0E0             dispdptrlcd:  push   acc           ;registers bewaren op stack
     639     639   00285 C0D0                           push   psw
     640     640   00287 E583                           mov    a,dph         ;hoge deel eerst naar het scherm
     641     641   00289 120272                         lcall  outbytelcd
     642     642   0028C E582                           mov    a,dpl         ;dan het lage deel
     643     643   0028E 120272                         lcall  outbytelcd
     644     644   00291 D0D0                           pop    psw
     645     645   00293 D0E0                           pop    acc
     646     646   00295 22                             ret
     647     647   00296                  
     648     648   00296                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     649     649   00296                  ;
     650     650   00296                  ; lcdoutmsga  zal een string ascii codes op het scherm plaatsen. Het startadres
     651     651   00296                  ; van de string staat in de dptr. De string wordt afgesloten met een 000h.
     652     652   00296                  ; De routine gebruikt outcharlcd voor het sturen van karakters naar het LCD
     653     653   00296                  ; scherm. Positionnering van de cursor en cursorcontrole kan in de ascii string
     654     654   00296                  ; opgenomen worden met de pseudo ascii codes (zie outcharlcd).
     655     655   00296                  ;
     656     656   00296                  ; de routine gebruikt geen registers
     657     657   00296                  ;
     658     658   00296                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     659     659   00296                  
     660     660   00296                  lcdoutmsga:
     661     661   00296 C0E0             outmsgalcd:   push   acc           ;registers op de stack
     662     662   00298 C0D0                           push   psw
     663     663   0029A C083                           push   dph           ;ook de data pointer
     664     664   0029C C082                           push   dpl
     665     665   0029E                  
     666     666   0029E                  ;We lezen karakters uit code memory tot de 000h code gevonden wordt.
     667     667   0029E                  
     668     668   0029E E4               outmsgalcd1:  clr    a             ;waarde zit in onze weg
     669     669   0029F 93                             movc   a,@a+dptr     ;waarde lezen
     670     670   002A0 6007                           jz     outmsgalcde   ;als 0 dan naar einde springen
     671     671   002A2                  
     672     672   002A2                  ; de code is niet 0 dus versturen met outchar
     673     673   002A2                  
     674     674   002A2 120204                         lcall  outcharlcd    ;weg er mee
     675     675   002A5 A3                             inc    dptr          ;naar volgende ascii code wijzen
     676     676   002A6 02029E                         ljmp   outmsgalcd1   ;lus sluiten
     677     677   002A9                  
     678     678   002A9 D082             outmsgalcde:  pop    dpl           ;registers herstellen
     679     679   002AB D083                           pop    dph
     680     680   002AD D0D0                           pop    psw
     681     681   002AF D0E0                           pop    acc
     682     682   002B1 22                             ret
     683     683   002B2                  
     684     684   002B2                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     685     685   002B2                  ;
     686     686   002B2                  ; outd is een routine die naar het data register van het display een
     687     687   002B2                  ; volledige byte stuurt.
     688     688   002B2                  ;
     689     689   002B2                  ; De routine gebruikt geen registers.
     690     690   002B2                  ;
     691     691   002B2                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     692     692   002B2                  
     693     693   002B2 C0E0             outd:         push   acc           ;registers op stack zetten
     694     694   002B4 C0D0                           push   psw
     695     695   002B6 1202C2                         lcall  outhnibd      ;hoogste vier bits verzenden
     696     696   002B9 C4                             swap   a             ;bitjes omruilen
     697     697   002BA 1202C2                         lcall  outhnibd      ;naar het scherm sturen
     698     698   002BD D0D0                           pop    psw           ;registers terug herstellen
     699     699   002BF D0E0                           pop    acc
     700     700   002C1 22                             ret
     701     701   002C2                  
     702     702   002C2                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     703     703   002C2                  ;
     704     704   002C2                  ; outhnibd stuurt de hoge 4 bits van de accu naar het data register van het
     705     705   002C2                  ; lcd scherm.
     706     706   002C2                  ;
     707     707   002C2                  ; de routine gebruikt geen registers.
     708     708   002C2                  ;
     709     709   002C2                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     710     710   002C2                  
     711     711   002C2 C0E0             outhnibd:     push   acc           ;registers op stack plaatsen
     712     712   002C4 C0D0                           push   psw
     713     713   002C6 C0F0                           push   b             ;werkregister
     714     714   002C8 120363                         lcall  lcdtoport     ;lees de expander naar b register
     715     715   002CB D2F0                           setb   rs            ;controle lijn in orde
     716     716   002CD C2F1                           clr    e             ;deselectie display
     717     717   002CF 54F0                           anl    a,#0f0h       ;hoogste 4 bits afzonderen
     718     718   002D1 03                             rr     a             ;bits op juiste plaats zetten
     719     719   002D2 03                             rr     a             ;voor b reg
     720     720   002D3 53F0C3                         anl    b,#11000011b  ;bits laag maken, worden vervangen door data in a
     721     721   002D6 42F0                           orl    b,a           ;bij elkaar voegen
     722     722   002D8 12034A                         lcall  porttolcd     ;naar expnder
     723     723   002DB D2F1                           setb   e             ;display enabelen
     724     724   002DD 12034A                         lcall  porttolcd
     725     725   002E0 C2F1                           clr    e             ;display deselecteren
     726     726   002E2 12034A                         lcall  porttolcd
     727     727   002E5 D0F0                           pop    b
     728     728   002E7 D0D0                           pop    psw           ;registers herstellen
     729     729   002E9 D0E0                           pop    acc
     730     730   002EB 22                             ret
     731     731   002EC                  
     732     732   002EC                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     733     733   002EC                  ;
     734     734   002EC                  ; outc is een routine die naar het controleregister van het display een
     735     735   002EC                  ; volledige byte stuurt.
     736     736   002EC                  ;
     737     737   002EC                  ; De routine gebruikt geen registers.
     738     738   002EC                  ;
     739     739   002EC                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     740     740   002EC                  
     741     741   002EC C0E0             outc:         push   acc           ;registers op stack zetten
     742     742   002EE C0D0                           push   psw
     743     743   002F0 120302                         lcall  outhnibc      ;hoogste vier bits verzenden
     744     744   002F3 120343                         lcall  delay2ms      ;niet echt nodig
     745     745   002F6 C4                             swap   a             ;bitjes omruilen
     746     746   002F7 120302                         lcall  outhnibc      ;naar het scherm sturen
     747     747   002FA 120343                         lcall  delay2ms      ;altijd goed voor traagste commando
     748     748   002FD D0D0                           pop    psw           ;registers terug herstellen
     749     749   002FF D0E0                           pop    acc
     750     750   00301 22                             ret
     751     751   00302                  
     752     752   00302                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     753     753   00302                  ;
     754     754   00302                  ; outhnibc stuurt de hoge 4 bits van de accu naar het controle register van het
     755     755   00302                  ; lcd scherm.
     756     756   00302                  ;
     757     757   00302                  ; de routine gebruikt geen registers.
     758     758   00302                  ;
     759     759   00302                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     760     760   00302                  
     761     761   00302 C0E0             outhnibc:     push   acc           ;registers op stack plaatsen
     762     762   00304 C0D0                           push   psw
     763     763   00306 C0F0                           push   b             ;werkregister
     764     764   00308 120363                         lcall  lcdtoport     ;lees de expander naar b register
     765     765   0030B C2F0                           clr    rs            ;controle lijn in orde
     766     766   0030D C2F1                           clr    e             ;deselectie display
     767     767   0030F 54F0                           anl    a,#0f0h       ;hoogste 4 bits afzonderen
     768     768   00311 03                             rr     a             ;bits op juiste plaats zetten
     769     769   00312 03                             rr     a             ;voor b reg
     770     770   00313 53F0C3                         anl    b,#11000011b  ;bits laag maken, worden vervangen door data in a
     771     771   00316 42F0                           orl    b,a           ;bij elkaar voegen
     772     772   00318 12034A                         lcall  porttolcd     ;naar expnder
     773     773   0031B D2F1                           setb   e             ;display enabelen
     774     774   0031D 12034A                         lcall  porttolcd
     775     775   00320 C2F1                           clr    e             ;display deselecteren
     776     776   00322 12034A                         lcall  porttolcd
     777     777   00325 D0F0                           pop    b
     778     778   00327 D0D0                           pop    psw           ;registers herstellen
     779     779   00329 D0E0                           pop    acc
     780     780   0032B 22                             ret
     781     781   0032C                  
     782     782   0032C                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     783     783   0032C                  ;
     784     784   0032C                  ; BUILD0 IS EEN ROUTINE DIE DE KARAKTERGENERATOR RAM ZAL LADEN MET HET
     785     785   0032C                  ; BITPATROON VOOR 8 KARAKTERS. DE ROUTINE GEBRUIKT EEN BITMAP OP HET ADRES
     786     786   0032C                  ; IN DPTR. DE TABEL WORDT AFGESLOTEN DOOR EEN BYTE MET BIT 7=1. DE ROUTINE
     787     787   0032C                  ; GEBRUIKT DPTR, ACC, PSW EN ENKELE LCD.DRV ROUTINES. NA HET VULLEN VAN DE
     788     788   0032C                  ; DATA RAM WORDT OPNIEUW ADRES 0 VAN DE DISPLAY RAM GESELECTEERD. ER WORDT GEEN
     789     789   0032C                  ; DATA GESCHREVEN.
     790     790   0032C                  ;
     791     791   0032C                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     792     792   0032C                  
     793     793   0032C 7440             BUILD:        MOV    A,#CGRAM      ;TOEGANG TOT KARAKTER GENERATOR RAM
     794     794   0032E 1202EC           BUILD1:       LCALL  OUTC          ;NAAR SCHERM VERSTUREN
     795     795   00331 7400             BUILD3:       MOV    A,#000H       ;ACCU OP NUL ZETTEN
     796     796   00333 93                             MOVC   A,@A+DPTR     ;EERSTE CODE UIT TABEL LEZEN
     797     797   00334 1202B2                         LCALL  OUTD          ;NAAR KARAKTER GENERATOR RAM STUREN
     798     798   00337 20E703                         JB     ACC.7,BUILD2  ;ALS BIT 1 DAN EINDE
     799     799   0033A A3                             INC    DPTR          ;NAAR VOLGENDE LOKATIE WIJZEN
     800     800   0033B 80F4                           SJMP   BUILD3
     801     801   0033D 7480             BUILD2:       MOV    A,#DDRAM      ;DATA DISPLAY RAM SELECTEREN
     802     802   0033F 1202EC                         LCALL  OUTC          ;NAAR KONTROLE REGISTER STUREN
     803     803   00342 22                             RET                  ;EINDE VAN DE ROUTINE
     804     804   00343                  
     805     805   00343                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     806     806   00343                  ;
     807     807   00343                  ; Delay2ms is een vertragingsroutine van 2ms.
     808     808   00343                  ;
     809     809   00343                  ; De routine gebruikt geen registers.
     810     810   00343                  ;
     811     811   00343                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     812     812   00343                  
     813     813   00343 120194           delay2ms:     lcall  delay1ms
     814     814   00346 120194                         lcall  delay1ms
     815     815   00349 22                             ret
     816     816   0034A                  
     817     817   0034A                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     818     818   0034A                  ;
     819     819   0034A                  ; porttolcd          is een subroutine die de inhoud van het b register naar het lcd
     820     820   0034A                  ; scherm stuurt via de port expander.
     821     821   0034A                  ;
     822     822   0034A                  ; Gebruikt geen registers
     823     823   0034A                  ;
     824     824   0034A                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     825     825   0034A                  
     826     826   0034A C0E0             porttolcd:    push   acc           ;geen registers gebruiken
     827     827   0034C C0D0                           push   psw           ;trekken ons niks aan van ack bit
     828     828   0034E 12006B                         lcall  iicstart      ;vertrokken
     829     829   00351 7440                           mov    a,#01000000b  ;schrijven naar expander
     830     830   00353 1200B2                         lcall  iicoutbyte    ;weg er mee
     831     831   00356 E5F0                           mov    a,b           ;data verzenden
     832     832   00358 1200B2                         lcall  iicoutbyte
     833     833   0035B 12008E                         lcall  iicstop       ;transactie sluiten
     834     834   0035E D0D0                           pop    psw
     835     835   00360 D0E0                           pop    acc
     836     836   00362 22                             ret
     837     837   00363                  
     838     838   00363                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     839     839   00363                  ;
     840     840   00363                  ; lcdtoport          is een subroutine die de waarde van de expander uitleest naar
     841     841   00363                  ; het b regiser. Op die manier kunnen we de expander laten onthouden wat de waarde
     842     842   00363                  ; van buzzet en backlight is.
     843     843   00363                  ;
     844     844   00363                  ; Gebruikt b register
     845     845   00363                  ;
     846     846   00363                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     847     847   00363                  
     848     848   00363 C0E0             lcdtoport:    push   acc           ;geen registers gebruiken
     849     849   00365 C0D0                           push   psw           ;trekken ons niks aan van ack bit
     850     850   00367 12006B                         lcall  iicstart      ;vertrokken
     851     851   0036A 7441                           mov    a,#01000001b  ;lezen van expander
     852     852   0036C 1200B2                         lcall  iicoutbyte    ;weg er mee
     853     853   0036F 12012D                         lcall  iicinbytenack ;data inlezen
     854     854   00372 12008E                         lcall  iicstop
     855     855   00375 F5F0                           mov    b,a
     856     856   00377 D0D0                           pop    psw
     857     857   00379 D0E0                           pop    acc
     858     858   0037B 22                             ret
     859     859   0037C                  
     860     860   0037C                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     861     861   0037C                  ;
     862     862   0037C                  ; lcdlighton         is een subroutine die de backlight inschakeld
     863     863   0037C                  ;
     864     864   0037C                  ; Gebruikt geen registers
     865     865   0037C                  ;
     866     866   0037C                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     867     867   0037C                  
     868     868   0037C C0F0             lcdlighton:   push   b
     869     869   0037E 120363                         lcall  lcdtoport     ;expander lezen
     870     870   00381 C2F6                           clr    b.6           ;licht aan doen
     871     871   00383 12034A                         lcall  porttolcd     ;expander scrijven
     872     872   00386 D0F0                           pop    b
     873     873   00388 22                             ret
     874     874   00389                  
     875     875   00389                  
     876     876   00389                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     877     877   00389                  ;
     878     878   00389                  ; lcdlightoff        is een subroutine die de backlight uitschakeld
     879     879   00389                  ;
     880     880   00389                  ; Gebruikt geen registers
     881     881   00389                  ;
     882     882   00389                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     883     883   00389                  
     884     884   00389 C0F0             lcdlightoff:  push   b
     885     885   0038B 120363                         lcall  lcdtoport     ;expander lezen
     886     886   0038E D2F6                           setb   b.6           ;licht uit doen
     887     887   00390 12034A                         lcall  porttolcd     ;expander scrijven
     888     888   00393 D0F0                           pop    b
     889     889   00395 22                             ret
     890     890   00396                  
     891     891   00396                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     892     892   00396                  ;
     893     893   00396                  ; lcdbuzon           is een subroutine die de buzzer inschakeld
     894     894   00396                  ;
     895     895   00396                  ; Gebruikt geen registers
     896     896   00396                  ;
     897     897   00396                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     898     898   00396                  
     899     899   00396 C0F0             lcdbuzon:     push   b
     900     900   00398 120363                         lcall  lcdtoport     ;expander lezen
     901     901   0039B C2F7                           clr    b.7           ;buzzer aan doen
     902     902   0039D 12034A                         lcall  porttolcd     ;expander scrijven
     903     903   003A0 D0F0                           pop    b
     904     904   003A2 22                             ret
     905     905   003A3                  
     906     906   003A3                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     907     907   003A3                  ;
     908     908   003A3                  ; lcdbuzoff          is een subroutine die de buzzer uitschakeld
     909     909   003A3                  ;
     910     910   003A3                  ; Gebruikt geen registers
     911     911   003A3                  ;
     912     912   003A3                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     913     913   003A3                  
     914     914   003A3 C0F0             lcdbuzoff:    push   b
     915     915   003A5 120363                         lcall  lcdtoport     ;expander lezen
     916     916   003A8 D2F7                           setb   b.7           ;buzzer aan doen
     917     917   003AA 12034A                         lcall  porttolcd     ;expander scrijven
     918     918   003AD D0F0                           pop    b
     919     919   003AF 22                             ret
     920     920   003B0                  
     921     921   003B0                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     922     922   003B0                  ;
     923     923   003B0                  ; Dit deel van de driver laat toe de USB verbinding met de PC te gebruiken als
     924     924   003B0                  ; een standaard com poort op 9600 baud.
     925     925   003B0                  ; De file laat toe om de seriele poort te gebruiken en biedt de standaard
     926     926   003B0                  ; monitorroutines zoals die beschikbaar zijn in de MGM monitors voor 8051.
     927     927   003B0                  ; De belangrijkste afwijking van de standaard routines is de initsio subroutine.
     928     928   003B0                  ; Die laat toe om 9600 baud in te stellen. Dit zal enkel kunnen met het xtal
     929     929   003B0                  ; ingeschakeld en met de CPU klok 24 Mhz. Het inschakelen van het XTAL gebeurt
     930     930   003B0                  ; NIET door deze routine.
     931     931   003B0                  ;
     932     932   003B0                  ; Geschreven door Roggemans Marc (MGM) op 07/2010 v0
     933     933   003B0                  ;
     934     934   003B0                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     935     935   003B0                  
     936     936   003B0                  blank         equ    020h          ;ascii code voor een blank
     937     937   003B0                  xoff          equ    013h          ;ascii code xoff caracter (ctrl s)
     938     938   003B0                  ff            equ    00ch          ;ascii code voor nieuw blad
     939     939   003B0                  cr            equ    00dh          ;ascii code voor een wagenterugloop
     940     940   003B0                  lf            equ    00ah          ;ascii code voor volgende lijn
     941     941   003B0                  backsp        equ    008h          ;ascii code voor het bs karakter
     942     942   003B0                  beep          equ    007h          ;ascii code voor een beep
     943     943   003B0                  
     944     944   003B0 08200800         wissen:       db     backsp,blank,backsp,000h    ;string wissen karakter
     945     945   003B4                                                                          ;van het scherm
     946     946   003B4                  
     947     947   003B4                  strtbuf       equ     054h         ;start adres van de buffer
     948     948   003B4                  endbuf        equ     07fh         ;laatst gebruikte locatie (kan cr bevatten)
     949     949   003B4                  
     950     950   003B4                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     951     951   003B4                  ;
     952     952   003B4                  ; initsio zal de seriele poort klaar zetten voor gebruik. De baudrate is 9600.
     953     953   003B4                  ;
     954     954   003B4                  ; Gebruikt geen registers
     955     955   003B4                  ;
     956     956   003B4                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     957     957   003B4                  
     958     958   003B4 C0E0             initsio:      push   acc                  ;registers op de stack zetten
     959     959   003B6 C08F                           push   syscon0              ;map bewaren
     960     960   003B8 758F04                         mov    syscon0,#004h        ;hier zit al wat we nodig hebben
     961     961   003BB C0B2                           push   port_page            ;pagina op stack zetten
     962     962   003BD C0BF                           push   scu_page
     963     963   003BF 75BF00                         mov    scu_page,#000h       ;pagina 0 system control regs
     964     964   003C2                  ; eerst gaan we de pinnen van poort 1 juist zetten:
     965     965   003C2                  ;      -p1.0 als input en alt1 selectie
     966     966   003C2                  ;      -p1.1 als output en alt2 selectie
     967     967   003C2                  
     968     968   003C2 75B202                         mov    port_page,#002h      ;pagina 2 selecteren
     969     969   003C5 5390FD                         anl    p1_altsel0,#11111101b
     970     970   003C8 439001                         orl    p1_altsel0,#00000001b
     971     971   003CB 5391FE                         anl    p1_altsel1,#11111110b
     972     972   003CE 439102                         orl    p1_altsel1,#00000010b
     973     973   003D1 75B200                         mov    port_page,#000h      ;pagina 0 selecteren
     974     974   003D4 5391FE                         anl    p1_dir,#11111110b    ;p1.0=input
     975     975   003D7 439102                         orl    p1_dir,#00000010b    ;p1.1=output
     976     976   003DA                  
     977     977   003DA                  ; Nu moet de baud rate generator ingesteld worden
     978     978   003DA                  ; We gaan er van uit dat de systeemklok 24MHz is
     979     979   003DA                  
     980     980   003DA 759850                         mov    scon,#01010000b      ;UART initialiseren
     981     981   003DD                  
     982     982   003DD                  ; LET OP!!!!!!!!!!!!!! eerst BG laden, dan bcon, anders wordt BG waarde niet
     983     983   003DD                  ; gebruikt!!
     984     984   003DD                  
     985     985   003DD 75BE9B                         mov    bg,#155              ;zie 12-13 in XC888 UM
     986     986   003E0 75BD11                         mov    bcon,#00010001b
     987     987   003E3 D0BF                           pop    scu_page
     988     988   003E5 D0B2                           pop    port_page            ;alles terug herstellen
     989     989   003E7 D08F                           pop    syscon0
     990     990   003E9 D0E0                           pop    acc
     991     991   003EB 22                             ret
     992     992   003EC                  
     993     993   003EC                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     994     994   003EC                  ;
     995     995   003EC                  ; SIOOUTCHAR IS EEN SUBROUTINE DIE EEN KARAKTER VIA DE SERIELE INTERFACE NAAR
     996     996   003EC                  ; BUITEN STUURT. DE ROUTINE GEBRUIKT DE ACCU ALS INPUT. DE ROUTINE GAAT NA DAT
     997     997   003EC                  ; DE TRANSMITTER LEEG IS ALVORENS HET KARAKTER TE VERSTUREN.
     998     998   003EC                  ;
     999     999   003EC                  ; de routine gebruikt geen registers.
    1000    1000   003EC                  ;
    1001    1001   003EC                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    1002    1002   003EC                  
    1003    1003   003EC                  siooutchar:
    1004    1004   003EC F599             OUTCHAR:      MOV    SBUF,A        ;KARAKTER VERZENDEN
    1005    1005   003EE 3099FD           OUTCHAR1:     JNB    TI,OUTCHAR1   ;WACHT TOT ZENDER BESCHIKBAAR
    1006    1006   003F1 C299                           CLR    TI            ;LAAG MAKEN VAN DE BIT
    1007    1007   003F3 22                             RET
    1008    1008   003F4                  
    1009    1009   003F4                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    1010    1010   003F4                  ;
    1011    1011   003F4                  ; SIOOUTNIB VERZEND DE LAAGSTE VIER BITS NAAR DE SERIELE POORT ONDER DE VORM VAN
    1012    1012   003F4                  ; EEN ASCII CODE. DE ACCU EN DE VLAGGEN WORDEN DOOR DE ROUTINE GEBRUIKT.
    1013    1013   003F4                  ;
    1014    1014   003F4                  ; de routine gebruikt geen registers.
    1015    1015   003F4                  ;
    1016    1016   003F4                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    1017    1017   003F4                  
    1018    1018   003F4                  siooutnib:
    1019    1019   003F4 C0E0             OUTNIB:       push   acc           ;registers op de stack
    1020    1020   003F6 C0D0                           push   psw
    1021    1021   003F8 540F                           ANL    A,#00FH       ;AFZONDEREN
    1022    1022   003FA 1204E4                         LCALL  BATRANS       ;OMZETTEN IN ASCII CODE
    1023    1023   003FD 1203EC                         LCALL  OUTCHAR       ;VERSTUREN
    1024    1024   00400 12044D                         LCALL  XONXOFF       ;FLOW CONTROL
    1025    1025   00403 D0D0                           pop    psw           ;registers herstellen
    1026    1026   00405 D0E0                           pop    acc
    1027    1027   00407 22                             RET
    1028    1028   00408                  
    1029    1029   00408                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    1030    1030   00408                  ;
    1031    1031   00408                  ; SIOOUTBYTE ZET DE HEX INHOUD VAN DE ACCU OP DE SERIELE POORT. ALS FLOW CONTROL
    1032    1032   00408                  ; WORDT XONXOFF GEBRUIKT.
    1033    1033   00408                  ;
    1034    1034   00408                  ; de routine gebruikt geen registers.
    1035    1035   00408                  ;
    1036    1036   00408                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    1037    1037   00408                  
    1038    1038   00408                  siooutbyte:
    1039    1039   00408 C0E0             OUTBYTE:      push   acc           ;registers op de stack zetten
    1040    1040   0040A C0D0                           push   psw
    1041    1041   0040C C0E0                           PUSH   ACC           ;BACK UP NEMEN VAN DE ACCU
    1042    1042   0040E C4                             SWAP   A             ;EERST HOOGSTE DEEL
    1043    1043   0040F 1203F4                         LCALL  OUTNIB        ;NIBBLE NAAR HET SCHERM
    1044    1044   00412 D0E0                           POP    ACC           ;HERSTELLEN VAN DE ACCU
    1045    1045   00414 1203F4                         LCALL  OUTNIB        ;NIBBLE NAAR HET SCHERM
    1046    1046   00417 D0D0                           pop    psw           ;registers herstellen
    1047    1047   00419 D0E0                           pop    acc
    1048    1048   0041B 22                             RET
    1049    1049   0041C                  
    1050    1050   0041C                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    1051    1051   0041C                  ;
    1052    1052   0041C                  ; SIODISPDPTR ZET DE HEX INHOUD VAN DE DPTR OP HET SCHERM OP DE HUIDIGE PLAATS
    1053    1053   0041C                  ; VAN DE CURSOR.
    1054    1054   0041C                  ;
    1055    1055   0041C                  ; de routine gebruikt geen registers.
    1056    1056   0041C                  ;
    1057    1057   0041C                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    1058    1058   0041C                  
    1059    1059   0041C                  siodispdptr:
    1060    1060   0041C C0E0             DISPDPTR:     push   acc           ;registers op de stack zetten
    1061    1061   0041E C0D0                           push   psw
    1062    1062   00420 E583                           MOV    A,DPH         ;EERST HOOGSTE DEEL OP SCHERM
    1063    1063   00422 120408                         LCALL  OUTBYTE       ;BYTE IN ASCII NAAR HET SCHERM
    1064    1064   00425 E582                           MOV    A,DPL         ;MINST BEDUIDENDE DEEL VERZENDEN
    1065    1065   00427 120408                         LCALL  OUTBYTE       ;WEG ER MEE
    1066    1066   0042A D0D0                           pop    psw           ;registers herstellen
    1067    1067   0042C D0E0                           pop    acc
    1068    1068   0042E 22                             RET                  ;EINDE
    1069    1069   0042F                  
    1070    1070   0042F                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    1071    1071   0042F                  ;
    1072    1072   0042F                  ; SIOOUTMSGA IS EEN SUBROUTINE, DIE DE ASCII CODES VANAF HET ADRES IN DE DPTR,
    1073    1073   0042F                  ; TOT AAN DE CODE 00H, OP HET SCHERM ZET. HET BERICHT STAAT IN CODE MEMORY.
    1074    1074   0042F                  ;
    1075    1075   0042F                  ; de routine gebruikt geen registers.
    1076    1076   0042F                  ;
    1077    1077   0042F                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    1078    1078   0042F                  
    1079    1079   0042F                  siooutmsga:
    1080    1080   0042F C0E0             OUTMSGA:      push   acc           ;alles op de stack zetten
    1081    1081   00431 C0D0                           push   psw
    1082    1082   00433 C082                           push   dpl
    1083    1083   00435 C083                           push   dph
    1084    1084   00437 E4               outmsga2:     CLR    A             ;ACCU LEEG MAKEN
    1085    1085   00438 93                             MOVC   A,@A+DPTR     ;EERSTE CODE OPHALEN
    1086    1086   00439 6009                           JZ     OUTMSGA1      ;ALS NUL DAN EINDE
    1087    1087   0043B 1203EC                         LCALL  OUTCHAR       ;KARAKTER NAAR HET SCHERM
    1088    1088   0043E 12044D                         LCALL  XONXOFF       ;SOFTWARE HANDSHAKE
    1089    1089   00441 A3                             INC    DPTR          ;DPTR AANPASSEN
    1090    1090   00442 80F3                           SJMP   OUTMSGA2      ;HERHAAL TOT EINDE
    1091    1091   00444 D083             OUTMSGA1:     pop    dph           ;alles herstellen
    1092    1092   00446 D082                           pop    dpl
    1093    1093   00448 D0D0                           pop    psw
    1094    1094   0044A D0E0                           pop    acc
    1095    1095   0044C 22                             RET                  ;EINDE ROUTINE
    1096    1096   0044D                  
    1097    1097   0044D                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    1098    1098   0044D                  ;
    1099    1099   0044D                  ; XONXOFF LAAT HET GEBRUIK VAN SOFTWARE HANDSHAKE TOE. DE ROUTINE GAAT NA DAT
    1100    1100   0044D                  ; ER EEN KARAKTER ONTVANGEN WERD. ALS DIT HET XOFF KARAKTER IS BLIJFT DE
    1101    1101   0044D                  ; ROUTINE WACHTEN OP EEN ANDER WILLEKEURIG KARAKTER. DIT LAATSTE WORDT NIET
    1102    1102   0044D                  ; VERDER DOORGEGEVEN.
    1103    1103   0044D                  ;
    1104    1104   0044D                  ; de routine gebruikt geen registers.
    1105    1105   0044D                  ;
    1106    1106   0044D                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    1107    1107   0044D                  
    1108    1108   0044D C0E0             XONXOFF:      push   acc           ;registers op de stack zetten
    1109    1109   0044F C0D0                           push   psw
    1110    1110   00451 109805                         JBC    RI,XONXOFF1   ;GA NA KARAKTER ONTVANGEN
    1111    1111   00454 D0D0             XONXOFF2:     pop    psw           ;registers herstellen
    1112    1112   00456 D0E0                           pop    acc
    1113    1113   00458 22                             RET                  ;ANDERS EINDE
    1114    1114   00459 E599             XONXOFF1:     MOV    A,SBUF        ;ZO JA, KARAKTER LADEN IN ACCU
    1115    1115   0045B B413F6                         CJNE   A,#XOFF,XONXOFF2     ;ALS NIET XOFF DAN VERDER
    1116    1116   0045E 1098F3           XONXOFF3:     JBC    RI,XONXOFF2   ;WACHTEN OP WILLEKEURIG KARAKTER
    1117    1117   00461 80FB                           SJMP   XONXOFF3      ;EN DAN RIBBE EN DE BIE
    1118    1118   00463                  
    1119    1119   00463                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    1120    1120   00463                  ;
    1121    1121   00463                  ; SIOINCHAR BLIJFT WACHTEN TOTDAT ER EEN KARAKTER ONTVANGEN WERD DOOR DE SERIELE
    1122    1122   00463                  ; INTERFACE. HET KARAKTER WORDT DOORGEGEVEN IN DE ACCUMULATOR.
    1123    1123   00463                  ;
    1124    1124   00463                  ; de routine gebruikt de accu.
    1125    1125   00463                  ;
    1126    1126   00463                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    1127    1127   00463                  
    1128    1128   00463                  sioinchar:
    1129    1129   00463 3098FD           INCHAR:       JNB    RI,INCHAR            ;BLIJF WACHTEN OP HET KARAKTER
    1130    1130   00466 C298                           CLR    RI                   ;BIT LAAG MAKEN
    1131    1131   00468 E599                           MOV    A,SBUF               ;KARAKTER IN DE ACCU
    1132    1132   0046A 22                             RET
    1133    1133   0046B                  
    1134    1134   0046B                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    1135    1135   0046B                  ;
    1136    1136   0046B                  ; SIOINBYTE LEEST TWEE ASCII CODES BINNEN EN VORMT ZE OM TOT EEN HEX BYTE.
    1137    1137   0046B                  ; ALS OUTPUT WORDT DE ACCU GEBRUIKT.
    1138    1138   0046B                  ; ALS HET DE TWEE ASCII CODES NIET TOT EEN BYTE OMGEZET KUNNEN WORDEN, ZAL
    1139    1139   0046B                  ; DE CARRY OP 1 GEZET WORDEN.
    1140    1140   0046B                  ;
    1141    1141   0046B                  ; De routine gebruikt de accu, r0 en de psw.
    1142    1142   0046B                  ;
    1143    1143   0046B                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    1144    1144   0046B                  
    1145    1145   0046B                  sioinbyte:
    1146    1146   0046B 120463           INBYTE:       LCALL  INCHAR               ;EERSTE KARAKTER INLEZEN
    1147    1147   0046E 1204D7                         LCALL  LOWUPTR
    1148    1148   00471 1204EE                         LCALL  ASCBINTRANS          ;OMZETTEN NAAR HEX GETAL
    1149    1149   00474 400E                           JC     INBYTE1              ;BIJ ERROR AKTIE ONDERNEMEN
    1150    1150   00476 C4                             SWAP   A                    ;IS HOOGSTE NIBBLE
    1151    1151   00477 F8                             MOV    R0,A                 ;ACCU TIJDELIJK BEWAREN
    1152    1152   00478 120463                         LCALL  INCHAR               ;TWEEDE KARAKTER OPHALEN
    1153    1153   0047B 1204D7                         LCALL  LOWUPTR
    1154    1154   0047E 1204EE                         LCALL  ASCBINTRANS          ;OMZETTEN NAAR BIN GETAL
    1155    1155   00481 4001                           JC     INBYTE1              ;BIJ ERROR ....
    1156    1156   00483 48                             ORL    A,R0                 ;BIJDE GETALLEN SAMEN VOEGEN
    1157    1157   00484 22               INBYTE1:      RET
    1158    1158   00485                  
    1159    1159   00485                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    1160    1160   00485                  ;
    1161    1161   00485                  ; SIOINBUFA LEEST EEN ASCII BUFFER BINNEN VIA DE SERIELE POORT. DE ROUTINE LAAT
    1162    1162   00485                  ; TOE OM FOUTIEVE INGAVEN TE VERBETEREN. HIERVOOR KAN DE BACKSPACE TOETS
    1163    1163   00485                  ; GEBRUIKT WORDEN. HET STARTADRES VAN DE BUFFER IS STRTBUF. DE LAATSE BYTE
    1164    1164   00485                  ; HEEFT HET ADRES ENDBUF. ALS DE BUFFER TE VOL, OF TE LEEG, GEMAAKT WORDT,
    1165    1165   00485                  ; LAAT DE CPU EEN BEEP HOREN. DE ROUTINE GEBRUIKT DE ACCU EN R0. CONTROLE
    1166    1166   00485                  ; KARAKTERS WORDEN NIET VERWERKT. DE ROUTINE GEEFT OOK EEN ECHO NAAR HET
    1167    1167   00485                  ; SCHERM. ZE GEBRUIKT DE SUBROUTINES INCHAR, OUTCHAR EN ASCCTR. INBUFA DOET
    1168    1168   00485                  ; OOK DE OMVORMING NAAR ASCII 0 KARAKTERS. Door de waarden van strtbuf en endbuf
    1169    1169   00485                  ; aan te passen kan de gebruiker zelf de lengte en de plaats van de buffer
    1170    1170   00485                  ; bepalen.
    1171    1171   00485                  ;
    1172    1172   00485                  ; De routine gebruikt de accu, r0 en de psw.
    1173    1173   00485                  ;
    1174    1174   00485                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    1175    1175   00485                  
    1176    1176   00485                  sioinbufa:
    1177    1177   00485 7854             INBUFA:       MOV    R0,#STRTBUF          ;START ADRES VAN DE BUFFER LADEN
    1178    1178   00487 120463           INBUFA2:      LCALL  INCHAR               ;KARAKTER LEZEN
    1179    1179   0048A 547F                           ANL    A,#07FH              ;KARAKTERS OMVORMEN TOT ASCII 0
    1180    1180   0048C                  ; ALVORENS EEN ECHO NAAR HET SCHERM TE VERSTUREN, MOET NAGEGAAN WORDEN DAT HET
    1181    1181   0048C                  ; BEKOMEN KARAKTER AAN DE TE VERWACHTEN KARAKTERS VOLDOET. DE ENIGE TOEGELATEN
    1182    1182   0048C                  ; CONTROLEKARAKTERS ZIJN 'CR' EN 'BACKSPACE'. VOOR AL DE ANDERE KARAKTERS
    1183    1183   0048C                  ; WORDT EEN BEEP NAAR HET SCHERM GESTUURD. DE CONTROLE WORDT DOOR ASCCTR UIT-
    1184    1184   0048C                  ; GEVOERD.
    1185    1185   0048C 1204D7                         LCALL  LOWUPTR              ;WEL EFFE IN CAPS TE ZETTEN
    1186    1186   0048F B40D02                         CJNE   A,#CR,INBUFA1        ;CR INGEGEVEN?
    1187    1187   00492 F6                             MOV    @R0,A                ;IN GEHEUGEN ZETTEN
    1188    1188   00493 22                             RET                         ;EINDE VAN DE ROUTINE
    1189    1189   00494 B40813           INBUFA1:      CJNE   A,#BACKSP,INBUFA6    ;NAGAAN BACK SPACE INDRUKKEN
    1190    1190   00497 B85407                         CJNE   R0,#STRTBUF,INBUFA3  ;STAAT DE BUFFER ONDERAAN,DAN BEEP
    1191    1191   0049A 7407             INBUFA4:      MOV    A,#BEEP
    1192    1192   0049C 1203EC           INBUFA7:      LCALL  OUTCHAR
    1193    1193   0049F 80E6                           SJMP   INBUFA2              ;NIEUW KARAKTER OPHALEN
    1194    1194   004A1 18               INBUFA3:      DEC    R0                   ;ENTRY UIT BUFFER HALEN
    1195    1195   004A2 9003B0                         MOV    DPTR,#wissen         ;WIS KARAKTER DATA NAAR SCHERM
    1196    1196   004A5 12042F                         LCALL  OUTMSGA
    1197    1197   004A8 80DD                           SJMP   INBUFA2              ;WACHT OP VOLGENDE INGAVE
    1198    1198   004AA 1204C9           INBUFA6:      LCALL  ASCCTR               ;ALS CARRY DAN NIET GELDIG
    1199    1199   004AD 40EB                           JC     INBUFA4              ;BEEP NAAR SCHERM
    1200    1200   004AF B87E02                         CJNE   R0,#ENDBUF-1,INBUFA5 ;BUFFER OP HET EINDE DAN ERROR
    1201    1201   004B2 80E6                           SJMP   INBUFA4              ;BEEP NAAR HET SCHERM
    1202    1202   004B4 F6               INBUFA5:      MOV    @R0,A                ;KARAKTER IN DE BUFFER
    1203    1203   004B5 08                             INC    R0                   ;BUFFER POINTER AANPASSEN
    1204    1204   004B6 80E4                           SJMP   INBUFA7              ;KARAKTER IN BUFFER, VOLGENDE ?
    1205    1205   004B8                  
    1206    1206   004B8                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    1207    1207   004B8                  ;
    1208    1208   004B8                  ; BDELETE HAALT ALLE blank KARAKTERS UIT de inputbuffer
    1209    1209   004B8                  ;
    1210    1210   004B8                  ; De routine gebruikt de accu, r0, r1 en de psw.
    1211    1211   004B8                  ;
    1212    1212   004B8                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    1213    1213   004B8                  
    1214    1214   004B8 7854             BDELETE:      MOV    R0,#STRTBUF          ;START ADRES IN R0
    1215    1215   004BA 7954                           MOV    R1,#STRTBUF          ;START ADRES IN R1
    1216    1216   004BC E6               BDELETE1:     MOV    A,@R0                ;LEES KARAKTER
    1217    1217   004BD B42005                         CJNE   A,#BLANK,BDELETE2    ;KARAKTER GEEN BLANKO,DAN BDELETE2
    1218    1218   004C0 08               BDELETE3:     INC    R0                   ;VOLGENDE KARAKTER OPHALEN
    1219    1219   004C1 B880F8                         CJNE   R0,#ENDBUF+1,BDELETE1 ;ALS NIET EINDE DAN VERDER
    1220    1220   004C4 22                             RET                         ;EINDE VAN DE ROUTINE
    1221    1221   004C5 F7               BDELETE2:     MOV    @R1,A                ;KARAKTER NAAR BUFFER STUREN
    1222    1222   004C6 09                             INC    R1
    1223    1223   004C7 80F7                           SJMP   BDELETE3
    1224    1224   004C9                  
    1225    1225   004C9                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    1226    1226   004C9                  ;
    1227    1227   004C9                  ; ASCCTR MOET NAGAAN DAT HET KARAKTER IN DE ACCU BIJ DE STANDAARD KARAKTERS
    1228    1228   004C9                  ; HOORT. ENKEL DE KONTROLEKARAKTERS CR EN BP ZIJN TOEGELATEN. DE ACCU EN DE
    1229    1229   004C9                  ; VLAGGEN WORDEN GEBRUIKT. DE KARAKTERS < 020H EN > DAN 07EH WORDEN ALS FOUT
    1230    1230   004C9                  ; AANZIEN.
    1231    1231   004C9                  ;
    1232    1232   004C9                  ; De routine gebruikt de accu en de psw.
    1233    1233   004C9                  ;
    1234    1234   004C9                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    1235    1235   004C9                  
    1236    1236   004C9 B42000           ASCCTR:       CJNE   A,#020H,ASCCTR1      ;NAGAAN KARAKTER KLEINER DAN
    1237    1237   004CC 4007             ASCCTR1:      JC     ASCCTR3              ;CARRY, DAN ERROR
    1238    1238   004CE B47F00                         CJNE   A,#07FH,ASCCTR2      ;GROTER DAN 7EH
    1239    1239   004D1 5002             ASCCTR2:      JNC    ASCCTR3              ;GEEN CARRY DAN ERROR
    1240    1240   004D3 C3                             CLR    C                    ;AANGEVEN GEEN FOUT
    1241    1241   004D4 22                             RET
    1242    1242   004D5 D3               ASCCTR3:      SETB   C                    ;AANGEVEN FOUT TOESTAND
    1243    1243   004D6 22                             RET
    1244    1244   004D7                  
    1245    1245   004D7                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    1246    1246   004D7                  ;
    1247    1247   004D7                  ; LOWUPTR ZET HET KARAKTER IN DE ACCU OM VAN LOWER NAAR UPPER CASE. DE ROUTINE
    1248    1248   004D7                  ; GEBRUIKT DE VLAGGEN EN DE ACCU. DE HEX WAARDEN 61H TOT EN MET 7AH MOETEN
    1249    1249   004D7                  ; OMGEZET WORDEN NAAR 41H TOT EN MET 5AH. DE ANDERE GETALLEN MOGEN NIET
    1250    1250   004D7                  ; AANGEPAST WORDEN.
    1251    1251   004D7                  ;
    1252    1252   004D7                  ; De routine gebruikt de accu en de psw.
    1253    1253   004D7                  ;
    1254    1254   004D7                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    1255    1255   004D7                  
    1256    1256   004D7 B47B00           LOWUPTR:      CJNE   A,#07BH,LOWUPTR1     ;BOVENSTE GRENS
    1257    1257   004DA 5007             LOWUPTR1:     JNC    LOWUPTR2             ;GEEN CARRY DAN GEEN OMZETTING
    1258    1258   004DC B46100                         CJNE   A,#061H,LOWUPTR3     ;ONDERSTE GRENS NAGAAN
    1259    1259   004DF 4002             LOWUPTR3:     JC     LOWUPTR2             ;CARRY DAN GEEN OMZETTING
    1260    1260   004E1 9420                           SUBB   A,#020H              ;OMZETTING
    1261    1261   004E3 22               LOWUPTR2:     RET                         ;EINDE OMZETTING
    1262    1262   004E4                  
    1263    1263   004E4                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    1264    1264   004E4                  ;
    1265    1265   004E4                  ; BATRANS DOET DE OMZETTING VAN EEN HEX NIBBLE IN DE ACCU NAAR DE PASSENDE
    1266    1266   004E4                  ; ASCII CODE.
    1267    1267   004E4                  ;
    1268    1268   004E4                  ; De routine gebruikt de accu en de psw.
    1269    1269   004E4                  ;
    1270    1270   004E4                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    1271    1271   004E4                  
    1272    1272   004E4 B40A00           BATRANS:      CJNE   A,#00AH,BATRANS1     ;NAGAAN 30 OF 37 MOETEN BIJ OPTELLEN
    1273    1273   004E7 4002             BATRANS1:     JC     BATRANS2             ;CARRY=1 DAN SLECHTS 30
    1274    1274   004E9 2407                           ADD    A,#007H              ;ANDERS 30+7=37
    1275    1275   004EB 2430             BATRANS2:     ADD    A,#030H              ;30 BIJ OPTELLEN
    1276    1276   004ED 22                             RET
    1277    1277   004EE                  
    1278    1278   004EE                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    1279    1279   004EE                  ;
    1280    1280   004EE                  ; ASCBINTRANS ZET HET ASCII KARAKTER IN DE ACCU OM IN EEN BINAIR GETAL. DE
    1281    1281   004EE                  ; ROUTINE KAN ENKEL DE KARAKTERS TUSSEN 0-9 EN A-F VERWERKEN. IN HET ANDERE
    1282    1282   004EE                  ; GEVAL WORDT DE CARRY GEZET.
    1283    1283   004EE                  ;
    1284    1284   004EE                  ; De routine gebruikt de accu en de psw.
    1285    1285   004EE                  ;
    1286    1286   004EE                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    1287    1287   004EE                  
    1288    1288   004EE C3               ASCBINTRANS:  CLR    C                    ;CARRY LAAG MAKEN VOOR BEREKENINGEN
    1289    1289   004EF 9430                           SUBB   A,#030H              ;NAGAAN GETAL BINNEN GRENZEN
    1290    1290   004F1 4010                           JC     ASCBINTRANS1         ;ALS C=1 DAN FOUT
    1291    1291   004F3 B40A00                         CJNE   A,#00AH,ASCBINTRANS3 ;GETAL TUSSEN 0 EN 9 ?
    1292    1292   004F6 400A             ASCBINTRANS3: JC     ASCBINTRANS2         ;ALS CARRY DAN ALLES OK
    1293    1293   004F8 9407                           SUBB   A,#007H              ;VERDER MET DE OMZETTING
    1294    1294   004FA 4007                           JC     ASCBINTRANS1         ;ALS CARRY DAN ERROR
    1295    1295   004FC B41000                         CJNE   A,#010H,ASCBINTRANS4 ;CONTROLE OP TE GROTE GETALLEN
    1296    1296   004FF B3               ASCBINTRANS4: CPL    C                    ;CARRY COMPLEMENTEREN
    1297    1297   00500 4001                           JC     ASCBINTRANS1         ;ALS CARRY DAN FOUT IN HET GETAL
    1298    1298   00502 C3               ASCBINTRANS2: CLR    C                    ;CARRY LAAG MAKEN
    1299    1299   00503 22               ASCBINTRANS1: RET
    1300    1300   00504                  
    1301    1301   00504                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    1302    1302   00504                  ;
    1303    1303   00504                  ; ASCII1 ZET HET ASCII KARAKTER @R0 OM IN EEN HEX GETAL IN DE ACCU.
    1304    1304   00504                  ; DE ROUTINE VERANDERD OOK DE VLAGGEN.
    1305    1305   00504                  ;
    1306    1306   00504                  ; De routine gebruikt de accu en de psw.
    1307    1307   00504                  ;
    1308    1308   00504                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    1309    1309   00504                  
    1310    1310   00504 E6               ASCII1:       MOV    A,@R0                ;KARAKTER OPHALEN
    1311    1311   00505 1204EE                         LCALL  ASCBINTRANS          ;OMZETTING ASCII NAAR BINAIR
    1312    1312   00508 22                             RET                         ;EINDE OMZETTING
    1313    1313   00509                  
    1314    1314   00509                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    1315    1315   00509                  ;
    1316    1316   00509                  ; ASCII2 ZET TWEE ASCII KARAKTERS @R0 EN @(R0+1) OM NAAR EEN HEX KARAKTER
    1317    1317   00509                  ; IN DE ACCU. R0 WORDT MET EEN VERHOOGD. R1 WORDT AANGEPAST. ALS OP HET EINDE
    1318    1318   00509                  ; VAN DE ROUTINE DE CARRY GESET IS, DAN IS DE OMZETTING NIET MOGELIJK.
    1319    1319   00509                  ;
    1320    1320   00509                  ; De routine gebruikt de accu, r0, r1 en de psw.
    1321    1321   00509                  ;
    1322    1322   00509                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    1323    1323   00509                  
    1324    1324   00509 120504           ASCII2:       LCALL  ASCII1               ;OMZETTEN
    1325    1325   0050C 4009                           JC     ASCII21              ;CARRY 1 DAN OMZETTING NIET MOGELIJK
    1326    1326   0050E C4                             SWAP   A                    ;NIBBLE VAN PLAATS VERANDEREN
    1327    1327   0050F F9                             MOV    R1,A                 ;TIJDELIJK WEG STOPPEN
    1328    1328   00510 08                             INC    R0                   ;NAAR VOLGENDE KARAKTER WIJZEN
    1329    1329   00511 120504                         LCALL  ASCII1               ;KARAKTER OMZETTEN
    1330    1330   00514 4001                           JC     ASCII21               ;WEG ALS C=1
    1331    1331   00516 49                             ORL    A,R1                 ;GETALLEN BIJ ELKAAR VOEGEN
    1332    1332   00517 22               ASCII21:      RET
    1333    1333   00518                  
    1334    1334   00518                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    1335    1335   00518                  ;
    1336    1336   00518                  ; ASCII4 ZET DE 4 ASCII KARAKTERS @R0 TOT @[R0+3] OM IN EEN HEX GETAL IN DE
    1337    1337   00518                  ; DATAPOINTER. ALS DE OMZETTING NIET MOGELIJK IS WORDT DE CARRY GEZET.
    1338    1338   00518                  ; R0 WORDT MET DRIE VERHOOGD, EN DE ACCU WORDT AANGEPAST,ALSOOK R1. ALS OP HET
    1339    1339   00518                  ; EINDE VAN DE ROUTINE DE CARRY GESET IS, DAN WAS EEN OMZETTING NIET MOGELIJK.
    1340    1340   00518                  ;
    1341    1341   00518                  ; De routine gebruikt de accu, r0, r1 en de psw.
    1342    1342   00518                  ;
    1343    1343   00518                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    1344    1344   00518                  
    1345    1345   00518 120509           ASCII4:       LCALL  ASCII2               ;OMZETTEN EERSTE TWEE ASCII BYTES
    1346    1346   0051B 400A                           JC     ASCII41              ;IN GEVAL VAN ERROR DAN WEG
    1347    1347   0051D F583                           MOV    DPH,A                ;HEX GETAL IN DE DPTRH
    1348    1348   0051F 08                             INC    R0                   ;WIIJST NU NAAR VOLGENDE GROEP VAN 2
    1349    1349   00520 120509                         LCALL  ASCII2               ;OMZETTEN VOLGENDE TWEE BYTES
    1350    1350   00523 4002                           JC     ASCII41              ;BIJ FOUT DAN WEG
    1351    1351   00525 F582                           MOV    DPL,A                ;IN DPTR LADEN
    1352    1352   00527 22               ASCII41:      RET
    1353    1353   00528                  
    1354    1354   00528                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    1355    1355   00528                  ;
    1356    1356   00528                  ; initadc            is een subroutine die de adc klaar zet voor minimalistisch
    1357    1357   00528                  ; gebruik De routine zorgt er voor dat de potmeter en de lm335 als analoge inputs
    1358    1358   00528                  ; geschakeld worden.
    1359    1359   00528                  ;
    1360    1360   00528                  ; Gebruikt geen registers
    1361    1361   00528                  ;
    1362    1362   00528                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    1363    1363   00528                  
    1364    1364   00528 C08F             initadc:      push   syscon0                     ;map saven
    1365    1365   0052A 758F04                         mov    syscon0,#004h               ;basis pagina selecteren
    1366    1366   0052D 75D100                         mov    adc_page,#000h              ;pagina 0 selecteren
    1367    1367   00530 75CAB0                         mov    adc_globctr,#10110000b      ;adc inschakelen                   MUST!!
    1368    1368   00533                                                                   ;klok delen door 32 (750kHz)
    1369    1369   00533                                                                   ;10 bit uitkomst
    1370    1370   00533 75CE0A                         mov    adc_inpcr0,#00ah            ;sample time verlengen met x klokpulsen
    1371    1371   00536                  ; Dit is niet echt nodig, maar hiermee vangen we de hoge impedantie van de potmeter op
    1372    1372   00536 75CC80                         mov    adc_prar,#080h              ;arbitration slot parallelle arbiratie activeren MUST!!
    1373    1373   00539 75D106                         mov    adc_page,#006h              ;adc page 6 selecteren             MUST!!
    1374    1374   0053C 75CC01                         mov    adc_crmr1,#001h             ;willen onmiddellijke actie        MUST!!
    1375    1375   0053F D08F                           pop    syscon0                     ;herstellen syscon
    1376    1376   00541 22                             ret
    1377    1377   00542                  
    1378    1378   00542                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    1379    1379   00542                  ;
    1380    1380   00542                  ; adclm335           is een subroutine die de spanning meet die van de lm335 sensor
    1381    1381   00542                  ; komt. De waarde wordt doorgegeven in a en b registers (kanaal 5).
    1382    1382   00542                  ;
    1383    1383   00542                  ; Gebruikt:
    1384    1384   00542                  ;      -accu als 8 msb meting
    1385    1385   00542                  ;      -b als 2 lsb meting (links afgelijnd) (b veat verder data van adc_resrxl)
    1386    1386   00542                  ;
    1387    1387   00542                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    1388    1388   00542                  
    1389    1389   00542 C08F             adclm335:     push   syscon0
    1390    1390   00544 758F04                         mov    syscon0,#004h               ;map kiezen en vorige bewaren
    1391    1391   00547 75D106                         mov    adc_page,#006h              ;adc pagina 6 kiezen
    1392    1392   0054A 75CB20                         mov    adc_crpr1,#00100000b        ;kanaal 5 starten
    1393    1393   0054D 75D100                         mov    adc_page,#000h              ;naar pagina 0 schakelen
    1394    1394   00550 00               		nop
    1395    1395   00551 00               		nop					;anders loopt het mis met het testen van de ready bit
    1396    1396   00552 E5CB             adclm3351:    mov    a,adc_globstr               ;kijken omvorming klaar
    1397    1397   00554 20E0FB                         jb     acc.0,adclm3351
    1398    1398   00557 75D102                         mov    adc_page,#002h              ;pagina 2 selecteren
    1399    1399   0055A E5CB                           mov    a,adc_resr0h                ;uitkomst in accu
    1400    1400   0055C 85CAF0                         mov    b,adc_resr0l                ;uitkomst in b
    1401    1401   0055F D08F                           pop    syscon0
    1402    1402   00561 22                             ret
    1403    1403   00562                  
    1404    1404   00562                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    1405    1405   00562                  ;
    1406    1406   00562                  ; adcpotmeter        is een subroutine die de spanning meet die van de potmeter
    1407    1407   00562                  ; komt. De waarde wordt doorgegeven in a en b registers (kanaal 4)
    1408    1408   00562                  ;
    1409    1409   00562                  ; Gebruikt:
    1410    1410   00562                  ;      -accu als 8 msb meting
    1411    1411   00562                  ;      -b als 2 lsb meting (links afgelijnd)
    1412    1412   00562                  ;
    1413    1413   00562                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    1414    1414   00562                  
    1415    1415   00562 C08F             adcpotmeter:  push   syscon0
    1416    1416   00564 758F04                         mov    syscon0,#004h               ;map kiezen en vorige bewaren
    1417    1417   00567 75D106                         mov    adc_page,#006h              ;adc pagina 6 kiezen
    1418    1418   0056A 75CB10                         mov    adc_crpr1,#00010000b        ;kanaal 4 starten
    1419    1419   0056D 75D100                         mov    adc_page,#000h              ;naar pagina 0 schakelen
    1420    1420   00570 00               		nop
    1421    1421   00571 00               		nop					;anders loopt het mis met het testen van de ready bit
    1422    1422   00572 E5CB             adcpotmeter1: mov    a,adc_globstr               ;kijken omvorming klaar
    1423    1423   00574 20E0FB                         jb     acc.0,adcpotmeter1
    1424    1424   00577 75D102                         mov    adc_page,#002h              ;pagina 2 selecteren
    1425    1425   0057A E5CB                           mov    a,adc_resr0h                ;uitkomst in accu
    1426    1426   0057C 85CAF0                         mov    b,adc_resr0l                ;uitkomst in b
    1427    1427   0057F D08F                           pop    syscon0
    1428    1428   00581                  
    1429    1429   00581                  
    1430    1430   00581 22                             ret
    1431    1431   00582                  
    1432    1432   00582                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    1433    1433   00582                  ;
    1434    1434   00582                  ; Dit is het driver gedeelte met de subroutines voor wiskundige berekeningen.
    1435    1435   00582                  ; Het is niet de bedoeling om de meest compacte code te bekomen. De driver zal
    1436    1436   00582                  ; ook niet alle gewenste routines bevatten. Hij is geschreven met pedagogische
    1437    1437   00582                  ; doelstellingen in het achterhoofd.
    1438    1438   00582                  ;
    1439    1439   00582                  ; De driver bevat routines voor 8 bit bcd naar hex en hex naar bcd omvorming
    1440    1440   00582                  ; LET OP!!!! de getallen moeten in waarde kleiner dan 100d zijn (zowel hex als
    1441    1441   00582                  ; bcd)
    1442    1442   00582                  ;      8bit hex naar bcd
    1443    1443   00582                  ;      8bit bcd naar hex
    1444    1444   00582                  ;
    1445    1445   00582                  ; De driver bevat routines voor de 4 hoofdbewerkingen op 16 bit getallen:
    1446    1446   00582                  ;      16/16 bit met 16 bit uitkomst en 16 bit rest
    1447    1447   00582                  ;      16*16 bit met 32 bit uitkomst
    1448    1448   00582                  ;      16+16 bit met 24 bit uitkomst
    1449    1449   00582                  ;      16-16 bit met 24 bit uitkomst
    1450    1450   00582                  ;      16bit hex naar bcd
    1451    1451   00582                  ;      16bit bcd naar hex
    1452    1452   00582                  ;
    1453    1453   00582                  ; De driver bevat routines voor de 4 hoofdbewerkingen op 32 bit getallen:
    1454    1454   00582                  ;      32/32 bit met 32 bit uitkomst en 32 bit rest
    1455    1455   00582                  ;      32*32 bit met 64 bit uitkomst
    1456    1456   00582                  ;      32+32 bit met 40 bit uitkomst
    1457    1457   00582                  ;      32-32 bit met 40 bit uitkomst
    1458    1458   00582                  ;
    1459    1459   00582                  ; de gebruiker moet zorgen dat de berekeningen mogelijk zijn!!!!!!!!!!!!!!!!!!
    1460    1460   00582                  ;
    1461    1461   00582                  ; De routines gebruiken als input en output de huidige registerbank.
    1462    1462   00582                  ;
    1463    1463   00582                  ;
    1464    1464   00582                  ; WAARSCHUWING!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    1465    1465   00582                  ; DEZE ROUTINES GEBRUIKEN 15 BYTES STACK. ZE WERKEN ENKEL ALS DE STACK NIET DE
    1466    1466   00582                  ; ADRESSEN 70-7c GEBRUIKT. ER WORDEN HIER IMMERS DIRECT ADRESSEERBARE REGISTERS
    1467    1467   00582                  ; VRIJ GEMAAKT OM IN TE REKENEN.
    1468    1468   00582                  ; !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    1469    1469   00582                  ;
    1470    1470   00582                  ; geschreven door Roggemans Marc (MGM) op 11/2004 uitvoering 51math0.inc
    1471    1471   00582                  ; Aangepast door Roggmans Marc (MGM) op 07/2010 voor xcez
    1472    1472   00582                  ;      -routines gebruiken geen MDU!
    1473    1473   00582                  ;
    1474    1474   00582                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    1475    1475   00582                  
    1476    1476   00582                  ; Hier worden gpr's verbonden met een naam. Ze worden gebruikt door sommige
    1477    1477   00582                  ; routines. Omdat ze informatie kunnen bevatten worden ze op de stack gezet.
    1478    1478   00582                  
    1479    1479   00582                  h0            equ    070h
    1480    1480   00582                  h1            equ    071h
    1481    1481   00582                  h2            equ    072h
    1482    1482   00582                  h3            equ    073h
    1483    1483   00582                  h4            equ    074h
    1484    1484   00582                  h5            equ    075h
    1485    1485   00582                  h6            equ    076h
    1486    1486   00582                  h7            equ    077h
    1487    1487   00582                  h8            equ    078h
    1488    1488   00582                  h9            equ    079h
    1489    1489   00582                  h10           equ    07ah
    1490    1490   00582                  h11           equ    07bh
    1491    1491   00582                  h12           equ    07ch
    1492    1492   00582                  
    1493    1493   00582                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    1494    1494   00582                  ;
    1495    1495   00582                  ; mul32       is de routine die twee 32 bit getallen zal vermenigvuldigen.
    1496    1496   00582                  ; input:      r3,r2,r1,r0 = eerste getal (r3=msb)
    1497    1497   00582                  ;             r7,r6,r5,r4 = tweede getal (r7=msb)
    1498    1498   00582                  ; output:     r7,r6,r5,r4,r3,r2,r1,r0 met r7=msb
    1499    1499   00582                  ;
    1500    1500   00582                  ; De routine gebruikt alleen de registers van de huidig geselecteerde bank
    1501    1501   00582                  ;
    1502    1502   00582                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    1503    1503   00582                  
    1504    1504   00582 C0E0             mul32:        push   acc                  ;registers op de stack zetten
    1505    1505   00584 C0D0                           push   psw
    1506    1506   00586 C070                           push   h0
    1507    1507   00588 C071                           push   h1
    1508    1508   0058A C072                           push   h2
    1509    1509   0058C C073                           push   h3
    1510    1510   0058E C074                           push   h4
    1511    1511   00590 C075                           push   h5
    1512    1512   00592 C076                           push   h6
    1513    1513   00594 C077                           push   h7
    1514    1514   00596 C078                           push   h8
    1515    1515   00598 C079                           push   h9
    1516    1516   0059A C07A                           push   h10
    1517    1517   0059C C07B                           push   h11
    1518    1518   0059E C07C                           push   h12
    1519    1519   005A0                  
    1520    1520   005A0                  ; eerst moeten de hulpregisters klaar gezet worden
    1521    1521   005A0                  
    1522    1522   005A0 757000                         mov    h0,#000h
    1523    1523   005A3 757100                         mov    h1,#000h
    1524    1524   005A6 757200                         mov    h2,#000h
    1525    1525   005A9 757300                         mov    h3,#000h
    1526    1526   005AC 757400                         mov    h4,#000h
    1527    1527   005AF 757500                         mov    h5,#000h
    1528    1528   005B2 757600                         mov    h6,#000h
    1529    1529   005B5 757700                         mov    h7,#000h
    1530    1530   005B8 757800                         mov    h8,#000h
    1531    1531   005BB 757900                         mov    h9,#000h
    1532    1532   005BE 757A00                         mov    h10,#000h
    1533    1533   005C1 757B00                         mov    h11,#000h
    1534    1534   005C4 757C20                         mov    h12,#32              ;loopcounter
    1535    1535   005C7                  
    1536    1536   005C7                  ; volgende lus moet 32 keer doorlopen worden om de berekening te maken
    1537    1537   005C7                  
    1538    1538   005C7                  ; nu wordt de vermenigvuldiger naar rechts in de carry geshift
    1539    1539   005C7                  
    1540    1540   005C7 EB               mul321:       mov    a,r3
    1541    1541   005C8 13                             rrc    a
    1542    1542   005C9 FB                             mov    r3,a
    1543    1543   005CA EA                             mov    a,r2
    1544    1544   005CB 13                             rrc    a
    1545    1545   005CC FA                             mov    r2,a
    1546    1546   005CD E9                             mov    a,r1
    1547    1547   005CE 13                             rrc    a
    1548    1548   005CF F9                             mov    r1,a
    1549    1549   005D0 E8                             mov    a,r0
    1550    1550   005D1 13                             rrc    a
    1551    1551   005D2 F8                             mov    r0,a                 ;32 bit shift klaar
    1552    1552   005D3                  
    1553    1553   005D3                  ;als de carry 1 is moet het 64 bit getal h3-r4 opgeteld worden bij h11-h4
    1554    1554   005D3                  
    1555    1555   005D3 502C                           jnc    mul322               ;optelling niet nodig
    1556    1556   005D5                  
    1557    1557   005D5                  ; hier staat en 64 bit optelling
    1558    1558   005D5                  
    1559    1559   005D5 EC                             mov    a,r4
    1560    1560   005D6 2574                           add    a,h4
    1561    1561   005D8 F574                           mov    h4,a
    1562    1562   005DA ED                             mov    a,r5
    1563    1563   005DB 3575                           addc   a,h5
    1564    1564   005DD F575                           mov    h5,a
    1565    1565   005DF EE                             mov    a,r6
    1566    1566   005E0 3576                           addc   a,h6
    1567    1567   005E2 F576                           mov    h6,a
    1568    1568   005E4 EF                             mov    a,r7
    1569    1569   005E5 3577                           addc   a,h7
    1570    1570   005E7 F577                           mov    h7,a
    1571    1571   005E9 E570                           mov    a,h0
    1572    1572   005EB 3578                           addc   a,h8
    1573    1573   005ED F578                           mov    h8,a
    1574    1574   005EF E571                           mov    a,h1
    1575    1575   005F1 3579                           addc   a,h9
    1576    1576   005F3 F579                           mov    h9,a
    1577    1577   005F5 E572                           mov    a,h2
    1578    1578   005F7 357A                           addc   a,h10
    1579    1579   005F9 F57A                           mov    h10,a
    1580    1580   005FB E573                           mov    a,h3
    1581    1581   005FD 357B                           addc   a,h11
    1582    1582   005FF F57B                           mov    h11,a                ;optelling klaar
    1583    1583   00601                  
    1584    1584   00601                  ; het getal h3-r4 moet met twee vermenigvuldigd worden
    1585    1585   00601                  
    1586    1586   00601 C3               mul322:       clr    c                    ;moet op 0 staan
    1587    1587   00602 EC                             mov    a,r4
    1588    1588   00603 33                             rlc    a
    1589    1589   00604 FC                             mov    r4,a
    1590    1590   00605 ED                             mov    a,r5
    1591    1591   00606 33                             rlc    a
    1592    1592   00607 FD                             mov    r5,a
    1593    1593   00608 EE                             mov    a,r6
    1594    1594   00609 33                             rlc    a
    1595    1595   0060A FE                             mov    r6,a
    1596    1596   0060B EF                             mov    a,r7
    1597    1597   0060C 33                             rlc    a
    1598    1598   0060D FF                             mov    r7,a
    1599    1599   0060E E570                           mov    a,h0
    1600    1600   00610 33                             rlc    a
    1601    1601   00611 F570                           mov    h0,a
    1602    1602   00613 E571                           mov    a,h1
    1603    1603   00615 33                             rlc    a
    1604    1604   00616 F571                           mov    h1,a
    1605    1605   00618 E572                           mov    a,h2
    1606    1606   0061A 33                             rlc    a
    1607    1607   0061B F572                           mov    h2,a
    1608    1608   0061D E573                           mov    a,h3
    1609    1609   0061F 33                             rlc    a
    1610    1610   00620 F573                           mov    h3,a
    1611    1611   00622                  
    1612    1612   00622 D57CA2                         djnz   h12,mul321           ;herhaal 32 keer
    1613    1613   00625                  
    1614    1614   00625                  ; de uitkomst moet in de juiste registers komen
    1615    1615   00625                  
    1616    1616   00625 A874                           mov    r0,h4
    1617    1617   00627 A975                           mov    r1,h5
    1618    1618   00629 AA76                           mov    r2,h6
    1619    1619   0062B AB77                           mov    r3,h7
    1620    1620   0062D AC78                           mov    r4,h8
    1621    1621   0062F AD79                           mov    r5,h9
    1622    1622   00631 AE7A                           mov    r6,h10
    1623    1623   00633 AF7B                           mov    r7,h11               ;klaar
    1624    1624   00635                  
    1625    1625   00635 D07C                           pop    h12                  ;registers herstellen
    1626    1626   00637 D07B                           pop    h11
    1627    1627   00639 D07A                           pop    h10
    1628    1628   0063B D079                           pop    h9
    1629    1629   0063D D078                           pop    h8
    1630    1630   0063F D077                           pop    h7
    1631    1631   00641 D076                           pop    h6
    1632    1632   00643 D075                           pop    h5
    1633    1633   00645 D074                           pop    h4
    1634    1634   00647 D073                           pop    h3
    1635    1635   00649 D072                           pop    h2
    1636    1636   0064B D071                           pop    h1
    1637    1637   0064D D070                           pop    h0
    1638    1638   0064F D0D0                           pop    psw
    1639    1639   00651 D0E0                           pop    acc
    1640    1640   00653 22                             ret
    1641    1641   00654                  
    1642    1642   00654                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    1643    1643   00654                  ;
    1644    1644   00654                  ; mul16       is de routine die twee 16 bit getallen zal vermenigvuldigen.
    1645    1645   00654                  ; input:      r1,r0 = eerste getal (r1=msb)
    1646    1646   00654                  ;             r3,r2 = tweede getal (r3=msb)
    1647    1647   00654                  ; output:     r3,r2,r1,r0 met r3=msb
    1648    1648   00654                  ;
    1649    1649   00654                  ; De routine gebruikt alleen de registers r3, r2, r1, r0 van de huidige bank
    1650    1650   00654                  ;
    1651    1651   00654                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    1652    1652   00654                  
    1653    1653   00654 C0E0             mul16:        push   acc                  ;registers op de stack zetten
    1654    1654   00656 C0D0                           push   psw
    1655    1655   00658 C070                           push   h0
    1656    1656   0065A C071                           push   h1
    1657    1657   0065C C072                           push   h2
    1658    1658   0065E C073                           push   h3
    1659    1659   00660 C074                           push   h4
    1660    1660   00662 C075                           push   h5
    1661    1661   00664 C076                           push   h6
    1662    1662   00666                  
    1663    1663   00666                  ; eerst registers laden met startwaarden. h0 en h1 zijn het verlengstuk
    1664    1664   00666                  ; van r3 en r2. h2, h3, h4, h5 worden gebruikt voor sommatie.
    1665    1665   00666                  ; h6 is de loopcounter.
    1666    1666   00666                  
    1667    1667   00666 757000                         mov    h0,#000h
    1668    1668   00669 757100                         mov    h1,#000h
    1669    1669   0066C 757200                         mov    h2,#000h
    1670    1670   0066F 757300                         mov    h3,#000h
    1671    1671   00672 757400                         mov    h4,#000h
    1672    1672   00675 757500                         mov    h5,#000h
    1673    1673   00678 757610                         mov    h6,#16               ;loopcounter
    1674    1674   0067B                  
    1675    1675   0067B                  ; hier staat de lus die 16 keer doorlopen wordt voor het uitvoeren van de
    1676    1676   0067B                  ; berekening
    1677    1677   0067B                  
    1678    1678   0067B E9               mul161:       mov    a,r1                 ;getal 1 1*rechts in carry
    1679    1679   0067C 13                             rrc    a
    1680    1680   0067D F9                             mov    r1,a
    1681    1681   0067E E8                             mov    a,r0
    1682    1682   0067F 13                             rrc    a
    1683    1683   00680 F8                             mov    r0,a                 ;ok
    1684    1684   00681                  
    1685    1685   00681                  ; als carry 1 dan h1, h0, r3, r2 optellen bij h5, h4, h3, h2
    1686    1686   00681                  
    1687    1687   00681 5016                           jnc    mul162
    1688    1688   00683                  
    1689    1689   00683 EA                             mov    a,r2
    1690    1690   00684 2572                           add    a,h2
    1691    1691   00686 F572                           mov    h2,a                 ;32 bit som uitvoeren
    1692    1692   00688 EB                             mov    a,r3
    1693    1693   00689 3573                           addc   a,h3
    1694    1694   0068B F573                           mov    h3,a
    1695    1695   0068D E570                           mov    a,h0
    1696    1696   0068F 3574                           addc   a,h4
    1697    1697   00691 F574                           mov    h4,a
    1698    1698   00693 E571                           mov    a,h1
    1699    1699   00695 3575                           addc   a,h5
    1700    1700   00697 F575                           mov    h5,a                 ;klaar
    1701    1701   00699                  
    1702    1702   00699                  ; het te vermenigvuldige getal maal 2 (1*links shiften)
    1703    1703   00699                  
    1704    1704   00699 C3               mul162:       clr    c
    1705    1705   0069A EA                             mov    a,r2
    1706    1706   0069B 33                             rlc    a
    1707    1707   0069C FA                             mov    r2,a                 ;ook 32 bit getal
    1708    1708   0069D EB                             mov    a,r3
    1709    1709   0069E 33                             rlc    a
    1710    1710   0069F FB                             mov    r3,a
    1711    1711   006A0 E570                           mov    a,h0
    1712    1712   006A2 33                             rlc    a
    1713    1713   006A3 F570                           mov    h0,a
    1714    1714   006A5 E571                           mov    a,h1
    1715    1715   006A7 33                             rlc    a
    1716    1716   006A8 F571                           mov    h1,a                 ;klaar
    1717    1717   006AA                  
    1718    1718   006AA D576CE                         djnz   h6,mul161            ;herhaal 16 keer
    1719    1719   006AD                  
    1720    1720   006AD                  ; de vermenigvuldiging is klaar. Nu uitkomstregisters laden
    1721    1721   006AD                  
    1722    1722   006AD A872                           mov    r0,h2
    1723    1723   006AF A973                           mov    r1,h3
    1724    1724   006B1 AA74                           mov    r2,h4
    1725    1725   006B3 AB75                           mov    r3,h5                ;klaar
    1726    1726   006B5                  
    1727    1727   006B5                  
    1728    1728   006B5 D076                           pop    h6                   ;registers herstellen
    1729    1729   006B7 D075                           pop    h5
    1730    1730   006B9 D074                           pop    h4
    1731    1731   006BB D073                           pop    h3
    1732    1732   006BD D072                           pop    h2
    1733    1733   006BF D071                           pop    h1
    1734    1734   006C1 D070                           pop    h0
    1735    1735   006C3 D0D0                           pop    psw
    1736    1736   006C5 D0E0                           pop    acc
    1737    1737   006C7 22                             ret
    1738    1738   006C8                  
    1739    1739   006C8                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    1740    1740   006C8                  ;
    1741    1741   006C8                  ; div32       is de routine die twee 32 bit getallen zal delen (eerste/tweede).
    1742    1742   006C8                  ; input:      r3,r2,r1,r0 = eerste getal (r3=msb)
    1743    1743   006C8                  ;             r7,r6,r5,r4 = tweede getal (r7=msb)
    1744    1744   006C8                  ; output:     r7,r6,r5,r4 = quotient (r7=msb)
    1745    1745   006C8                  ;             r3,r2,r1,r0 = rest (r3=msb)
    1746    1746   006C8                  ;             carry=1 bij delen door 0
    1747    1747   006C8                  ;
    1748    1748   006C8                  ; De routine gebruikt alleen de registers van de huidig geselecteerde bank
    1749    1749   006C8                  ;
    1750    1750   006C8                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    1751    1751   006C8                  
    1752    1752   006C8 C0E0             div32:        push   acc                  ;registers op de stack zetten
    1753    1753   006CA C0D0                           push   psw
    1754    1754   006CC C070                           push   h0
    1755    1755   006CE C071                           push   h1
    1756    1756   006D0 C072                           push   h2
    1757    1757   006D2 C073                           push   h3
    1758    1758   006D4 C074                           push   h4
    1759    1759   006D6 C075                           push   h5
    1760    1760   006D8 C076                           push   h6
    1761    1761   006DA C077                           push   h7
    1762    1762   006DC C078                           push   h8
    1763    1763   006DE C079                           push   h9
    1764    1764   006E0 C07A                           push   h10
    1765    1765   006E2 C07B                           push   h11
    1766    1766   006E4 C07C                           push   h12
    1767    1767   006E6                  
    1768    1768   006E6                  ; eerst alles voorladen
    1769    1769   006E6                  
    1770    1770   006E6 757000                         mov    h0,#000h
    1771    1771   006E9 757100                         mov    h1,#000h
    1772    1772   006EC 757200                         mov    h2,#000h
    1773    1773   006EF 757300                         mov    h3,#000h
    1774    1774   006F2 757400                         mov    h4,#000h
    1775    1775   006F5 757500                         mov    h5,#000h
    1776    1776   006F8 757600                         mov    h6,#000h
    1777    1777   006FB 757700                         mov    h7,#000h
    1778    1778   006FE 757800                         mov    h8,#000h
    1779    1779   00701 757900                         mov    h9,#000h
    1780    1780   00704 757A00                         mov    h10,#000h
    1781    1781   00707 757B00                         mov    h11,#000h
    1782    1782   0070A 757C20                         mov    h12,#32              ;loopcounter
    1783    1783   0070D                  
    1784    1784   0070D                  ; we gaan het te delen getal in de passende hulpregisters shiften
    1785    1785   0070D                  
    1786    1786   0070D                  ; deze lus moet 32 keer heraald worden
    1787    1787   0070D                  
    1788    1788   0070D E8               div321:       mov    a,r0                 ;h3-r0 is te delen getal
    1789    1789   0070E 33                             rlc    a
    1790    1790   0070F F8                             mov    r0,a
    1791    1791   00710 E9                             mov    a,r1
    1792    1792   00711 33                             rlc    a
    1793    1793   00712 F9                             mov    r1,a
    1794    1794   00713 EA                             mov    a,r2
    1795    1795   00714 33                             rlc    a
    1796    1796   00715 FA                             mov    r2,a
    1797    1797   00716 EB                             mov    a,r3
    1798    1798   00717 33                             rlc    a
    1799    1799   00718 FB                             mov    r3,a
    1800    1800   00719 E570                           mov    a,h0
    1801    1801   0071B 33                             rlc    a
    1802    1802   0071C F570                           mov    h0,a
    1803    1803   0071E E571                           mov    a,h1
    1804    1804   00720 33                             rlc    a
    1805    1805   00721 F571                           mov    h1,a
    1806    1806   00723 E572                           mov    a,h2
    1807    1807   00725 33                             rlc    a
    1808    1808   00726 F572                           mov    h2,a
    1809    1809   00728 E573                           mov    a,h3
    1810    1810   0072A 33                             rlc    a
    1811    1811   0072B F573                           mov    h3,a
    1812    1812   0072D                  
    1813    1813   0072D                  ; nu testen of het deeltal in h3-h0 past, tussenuitkomst in h7-h4
    1814    1814   0072D                  
    1815    1815   0072D C3                             clr    c                    ;zit in de weg
    1816    1816   0072E E570                           mov    a,h0
    1817    1817   00730 9C                             subb   a,r4
    1818    1818   00731 F574                           mov    h4,a
    1819    1819   00733 E571                           mov    a,h1
    1820    1820   00735 9D                             subb   a,r5
    1821    1821   00736 F575                           mov    h5,a
    1822    1822   00738 E572                           mov    a,h2
    1823    1823   0073A 9E                             subb   a,r6
    1824    1824   0073B F576                           mov    h6,a
    1825    1825   0073D E573                           mov    a,h3
    1826    1826   0073F 9F                             subb   a,r7
    1827    1827   00740 F577                           mov    h7,a
    1828    1828   00742                  
    1829    1829   00742                  ; als er geen carry is, dan is het verschil succesvol, en moeten h3-h0
    1830    1830   00742                  ; vervangen worden door h7-h4
    1831    1831   00742                  
    1832    1832   00742 400C                           jc     div322               ;niet vervangen
    1833    1833   00744                  
    1834    1834   00744 857470                         mov    h0,h4
    1835    1835   00747 857571                         mov    h1,h5
    1836    1836   0074A 857672                         mov    h2,h6
    1837    1837   0074D 857773                         mov    h3,h7                ;vervanging klaar
    1838    1838   00750                  
    1839    1839   00750 B3               div322:       cpl    c                    ;dit moet in h11-h8 (uitkomst)
    1840    1840   00751 E578                           mov    a,h8
    1841    1841   00753 33                             rlc    a
    1842    1842   00754 F578                           mov    h8,a
    1843    1843   00756 E579                           mov    a,h9
    1844    1844   00758 33                             rlc    a
    1845    1845   00759 F579                           mov    h9,a
    1846    1846   0075B E57A                           mov    a,h10
    1847    1847   0075D 33                             rlc    a
    1848    1848   0075E F57A                           mov    h10,a
    1849    1849   00760 E57B                           mov    a,h11
    1850    1850   00762 33                             rlc    a
    1851    1851   00763 F57B                           mov    h11,a                ;qoutient aangepast
    1852    1852   00765                  
    1853    1853   00765 D57CA5                         djnz   h12,div321           ;32 keer herhalen
    1854    1854   00768                  
    1855    1855   00768                  ; de berekening is klaar. uitkomstregisters nog laden
    1856    1856   00768                  
    1857    1857   00768 AC78                           mov    r4,h8
    1858    1858   0076A AD79                           mov    r5,h9
    1859    1859   0076C AE7A                           mov    r6,h10
    1860    1860   0076E AF7B                           mov    r7,h11               ;uitkomst geladen
    1861    1861   00770                  
    1862    1862   00770 A870                           mov    r0,h0                ;rest laden
    1863    1863   00772 A971                           mov    r1,h1
    1864    1864   00774 AA72                           mov    r2,h2
    1865    1865   00776 AB73                           mov    r3,h3
    1866    1866   00778                  
    1867    1867   00778 D07C                           pop    h12                  ;registers herstellen
    1868    1868   0077A D07B                           pop    h11
    1869    1869   0077C D07A                           pop    h10
    1870    1870   0077E D079                           pop    h9
    1871    1871   00780 D078                           pop    h8
    1872    1872   00782 D077                           pop    h7
    1873    1873   00784 D076                           pop    h6
    1874    1874   00786 D075                           pop    h5
    1875    1875   00788 D074                           pop    h4
    1876    1876   0078A D073                           pop    h3
    1877    1877   0078C D072                           pop    h2
    1878    1878   0078E D071                           pop    h1
    1879    1879   00790 D070                           pop    h0
    1880    1880   00792 D0D0                           pop    psw
    1881    1881   00794 D0E0                           pop    acc
    1882    1882   00796 22                             ret
    1883    1883   00797                  
    1884    1884   00797                  
    1885    1885   00797                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    1886    1886   00797                  ;
    1887    1887   00797                  ; div16       is de routine die twee 16 bit getallen zal delen (eerste/tweede).
    1888    1888   00797                  ; input:      r1,r0 = eerste getal (r1=msb)
    1889    1889   00797                  ;             r3,r2 = tweede getal (r3=msb)
    1890    1890   00797                  ; output:     r3,r2 = quotient (r3=msb)
    1891    1891   00797                  ;             r1,r0 = rest (r1=msb)
    1892    1892   00797                  ;             carry=1 bij deling door 0
    1893    1893   00797                  ;
    1894    1894   00797                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    1895    1895   00797                  
    1896    1896   00797 C0E0             div16:        push   acc                  ;registers op de stack zetten
    1897    1897   00799 C0D0                           push   psw
    1898    1898   0079B C070                           push   h0
    1899    1899   0079D C071                           push   h1
    1900    1900   0079F C072                           push   h2
    1901    1901   007A1 C073                           push   h3
    1902    1902   007A3 C074                           push   h4
    1903    1903   007A5 C075                           push   h5
    1904    1904   007A7 C076                           push   h6
    1905    1905   007A9                  
    1906    1906   007A9                  ; registers voorladen
    1907    1907   007A9                  
    1908    1908   007A9 757000                         mov    h0,#000h
    1909    1909   007AC 757100                         mov    h1,#000h
    1910    1910   007AF 757200                         mov    h2,#000h
    1911    1911   007B2 757300                         mov    h3,#000h
    1912    1912   007B5 757400                         mov    h4,#000h
    1913    1913   007B8 757500                         mov    h5,#000h
    1914    1914   007BB 757610                         mov    h6,#16               ;loopcounter
    1915    1915   007BE                  
    1916    1916   007BE                  ; eerst te delen getal 1*links shiften in hulpregisters
    1917    1917   007BE                  
    1918    1918   007BE                  ; deze lus moet 16 keer herhaald worden
    1919    1919   007BE                  
    1920    1920   007BE E8               div161:       mov    a,r0                 ;32 bit shift in h1-r0
    1921    1921   007BF 33                             rlc    a
    1922    1922   007C0 F8                             mov    r0,a
    1923    1923   007C1 E9                             mov    a,r1
    1924    1924   007C2 33                             rlc    a
    1925    1925   007C3 F9                             mov    r1,a
    1926    1926   007C4 E570                           mov    a,h0
    1927    1927   007C6 33                             rlc    a
    1928    1928   007C7 F570                           mov    h0,a
    1929    1929   007C9 E571                           mov    a,h1
    1930    1930   007CB 33                             rlc    a
    1931    1931   007CC F571                           mov    h1,a
    1932    1932   007CE                  
    1933    1933   007CE                  ; nagaan of in h1-h0 de deler past r3-r2. h3-h2 wordt gebruikt voor
    1934    1934   007CE                  ; het tussenresultaat.
    1935    1935   007CE                  
    1936    1936   007CE C3                             clr    c
    1937    1937   007CF E570                           mov    a,h0
    1938    1938   007D1 9A                             subb   a,r2
    1939    1939   007D2 F572                           mov    h2,a
    1940    1940   007D4 E571                           mov    a,h1
    1941    1941   007D6 9B                             subb   a,r3
    1942    1942   007D7 F573                           mov    h3,a
    1943    1943   007D9                  
    1944    1944   007D9 4006                           jc     div162               ;als carry dan h1-h0 niet vervangen
    1945    1945   007DB                                                            ;door h3,h2
    1946    1946   007DB 857270                         mov    h0,h2
    1947    1947   007DE 857371                         mov    h1,h3                ;vervanging klaar
    1948    1948   007E1                  
    1949    1949   007E1                  ; uitkomst moet aangepast worden
    1950    1950   007E1                  
    1951    1951   007E1 B3               div162:       cpl    c                    ;truuk
    1952    1952   007E2 E574                           mov    a,h4
    1953    1953   007E4 33                             rlc    a
    1954    1954   007E5 F574                           mov    h4,a
    1955    1955   007E7 E575                           mov    a,h5
    1956    1956   007E9 33                             rlc    a
    1957    1957   007EA F575                           mov    h5,a
    1958    1958   007EC D576CF                         djnz   h6,div161            ;16 keer herhalen
    1959    1959   007EF                  
    1960    1960   007EF                  ; de berekening is klaar. uitkomsten in passende registers
    1961    1961   007EF                  
    1962    1962   007EF AA74                           mov    r2,h4                ;quotient
    1963    1963   007F1 AB75                           mov    r3,h5
    1964    1964   007F3                  
    1965    1965   007F3 A870                           mov    r0,h0                ;rest
    1966    1966   007F5 A971                           mov    r1,h1
    1967    1967   007F7                  
    1968    1968   007F7 D076                           pop    h6                   ;registers herstellen
    1969    1969   007F9 D075                           pop    h5
    1970    1970   007FB D074                           pop    h4
    1971    1971   007FD D073                           pop    h3
    1972    1972   007FF D072                           pop    h2
    1973    1973   00801 D071                           pop    h1
    1974    1974   00803 D070                           pop    h0
    1975    1975   00805 D0D0                           pop    psw
    1976    1976   00807 D0E0                           pop    acc
    1977    1977   00809 22                             ret
    1978    1978   0080A                  
    1979    1979   0080A                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    1980    1980   0080A                  ;
    1981    1981   0080A                  ; add32       zal twee 32 bit getallen optellen en een 40 bit uitkomst.
    1982    1982   0080A                  ;
    1983    1983   0080A                  ; input:      r3,r2,r1,r0 = eerste getal (r3=msb)
    1984    1984   0080A                  ;             r7,r6,r5,r4 = tweede getal (r7=msb)
    1985    1985   0080A                  ; output:     r4,r3,r2,r1,r0 (r4=msb)
    1986    1986   0080A                  ;
    1987    1987   0080A                  ; r4,r3,r2,r1,r0 worden aangepast
    1988    1988   0080A                  ;
    1989    1989   0080A                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    1990    1990   0080A                  
    1991    1991   0080A C0E0             add32:        push   acc                  ;registers op de stack zetten
    1992    1992   0080C C0D0                           push   psw
    1993    1993   0080E E8                             mov    a,r0                 ;eerste 8 bit
    1994    1994   0080F 2C                             add    a,r4
    1995    1995   00810 F8                             mov    r0,a                 ;klaar
    1996    1996   00811 E9                             mov    a,r1                 ;volgende 8 bit
    1997    1997   00812 3D                             addc   a,r5
    1998    1998   00813 F9                             mov    r1,a                 ;klaar
    1999    1999   00814 EA                             mov    a,r2                 ;volgende 8 bit
    2000    2000   00815 3E                             addc   a,r6
    2001    2001   00816 FA                             mov    r2,a                 ;klaar
    2002    2002   00817 EB                             mov    a,r3                 ;laatste 8 bit
    2003    2003   00818 3F                             addc   a,r7
    2004    2004   00819 FB                             mov    r3,a                 ;32 bit klaar
    2005    2005   0081A 7400                           mov    a,#000h
    2006    2006   0081C 3400                           addc   a,#000h              ;carry verrekenen
    2007    2007   0081E FC                             mov    r4,a
    2008    2008   0081F D0D0                           pop    psw                  ;registers herstellen
    2009    2009   00821 D0E0                           pop    acc
    2010    2010   00823 22                             ret
    2011    2011   00824                  
    2012    2012   00824                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    2013    2013   00824                  ;
    2014    2014   00824                  ; add16       zal twee 16 bit getallen optellen en een 24 bit uitkomst.
    2015    2015   00824                  ;
    2016    2016   00824                  ; input:      r1,r0 = eerste getal (r1=msb)
    2017    2017   00824                  ;             r3,r2 = tweede getal (r3=msb)
    2018    2018   00824                  ; output:     r2,r1,r0 (r2=msb)
    2019    2019   00824                  ;
    2020    2020   00824                  ; r3,r2,r1,r0 worden aangepast
    2021    2021   00824                  ;
    2022    2022   00824                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    2023    2023   00824                  
    2024    2024   00824 C0E0             add16:        push   acc                  ;geen registers gebruiken behalve rx
    2025    2025   00826 C0D0                           push   psw
    2026    2026   00828 E8                             mov    a,r0                 ;starten met de optelling
    2027    2027   00829 2A                             add    a,r2                 ;8 bit klaar
    2028    2028   0082A F8                             mov    r0,a                 ;uitkomst wegschrijven
    2029    2029   0082B E9                             mov    a,r1                 ;volgende 8 bit
    2030    2030   0082C 3B                             addc   a,r3                 ;16 bit klaar
    2031    2031   0082D F9                             mov    r1,a                 ;uitkomst weggeschreven
    2032    2032   0082E 7400                           mov    a,#000h              ;carry verrekenen
    2033    2033   00830 3400                           addc   a,#000h
    2034    2034   00832 FA                             mov    r2,a                 ;24 bit klaar
    2035    2035   00833 D0D0                           pop    psw                  ;registers herstellen
    2036    2036   00835 D0E0                           pop    acc
    2037    2037   00837 22                             ret
    2038    2038   00838                  
    2039    2039   00838                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    2040    2040   00838                  ;
    2041    2041   00838                  ; sub32       zal het verschil berekenen van 2 32 bit getallen. De uitkomst is
    2042    2042   00838                  ;             40 bit groot. (eerste -tweede)
    2043    2043   00838                  ; input:      r3,r2,r1,r0 = eerste getal (r3=msb)
    2044    2044   00838                  ;             r7,r6,r5,r4 = tweede getal (r7=msb)
    2045    2045   00838                  ; output:     r4,r3,r2,r1,r0 (r4=msb)
    2046    2046   00838                  ;
    2047    2047   00838                  ; r4,r3,r2,r1,r0 worden aangepast
    2048    2048   00838                  ;
    2049    2049   00838                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    2050    2050   00838                  
    2051    2051   00838 C0E0             sub32:        push   acc                  ;registers bewaren
    2052    2052   0083A C0D0                           push   psw                  ;ook de vlaggen
    2053    2053   0083C C3                             clr    c                    ;zit nog effe in de weg
    2054    2054   0083D E8                             mov    a,r0                 ;eerste 8 bit
    2055    2055   0083E 9C                             subb   a,r4
    2056    2056   0083F F8                             mov    r0,a
    2057    2057   00840 E9                             mov    a,r1                 ;tweede 8 bit
    2058    2058   00841 9D                             subb   a,r5
    2059    2059   00842 F9                             mov    r1,a
    2060    2060   00843 EA                             mov    a,r2                 ;volgende 8 bit
    2061    2061   00844 9E                             subb   a,r6
    2062    2062   00845 FA                             mov    r2,a
    2063    2063   00846 EB                             mov    a,r3                 ;laatste 8 bit
    2064    2064   00847 9F                             subb   a,r7
    2065    2065   00848 FB                             mov    r3,a
    2066    2066   00849 7400                           mov    a,#000h              ;nu nog de carry
    2067    2067   0084B 9400                           subb   a,#000h
    2068    2068   0084D FC                             mov    r4,a                 ;40 bit klaar
    2069    2069   0084E D0D0                           pop    psw                  ;registers herstellen
    2070    2070   00850 D0E0                           pop    acc
    2071    2071   00852 22                             ret
    2072    2072   00853                  
    2073    2073   00853                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    2074    2074   00853                  ;
    2075    2075   00853                  ; sub16       zal het verschil berekenen van 2 16 bit getallen. De uitkomst is
    2076    2076   00853                  ;             24 bit groot. (eerste - tweede)
    2077    2077   00853                  ; input:      r1,r0 = eerste getal (r1=msb)
    2078    2078   00853                  ;             r3,r2 = tweede getal (r3=msb)
    2079    2079   00853                  ; output:     r2,r1,r0 (r2=msb)
    2080    2080   00853                  ;
    2081    2081   00853                  ; r3,r2,r1,r0 worden aangepast
    2082    2082   00853                  ;
    2083    2083   00853                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    2084    2084   00853                  
    2085    2085   00853 C0E0             sub16:        push   acc                  ;registers bewaren
    2086    2086   00855 C0D0                           push   psw
    2087    2087   00857 C3                             clr    c                    ;mag nog niet meespelen
    2088    2088   00858 E8                             mov    a,r0                 ;eerste 8 bit verschil
    2089    2089   00859 9A                             subb   a,r2
    2090    2090   0085A F8                             mov    r0,a                 ;klaar
    2091    2091   0085B E9                             mov    a,r1
    2092    2092   0085C 9B                             subb   a,r3                 ;16 bit klaar
    2093    2093   0085D F9                             mov    r1,a
    2094    2094   0085E 7400                           mov    a,#000h
    2095    2095   00860 9400                           subb   a,#000h              ;eventuele carry verrekenen
    2096    2096   00862 FA                             mov    r2,a                 ;24 bit klaar
    2097    2097   00863 D0D0                           pop    psw                  ;registers herstellen
    2098    2098   00865 D0E0                           pop    acc
    2099    2099   00867 22                             ret
    2100    2100   00868                  
    2101    2101   00868                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    2102    2102   00868                  ;
    2103    2103   00868                  ; hexbcd16    zet een 16 bit hex getal om in een 24 bit bcd getal
    2104    2104   00868                  ; input       r1,r0 = 16 bit hex getal (r1=msb)
    2105    2105   00868                  ; output      r2,r1,r0 =24 bit bcd getal (r2=msb)
    2106    2106   00868                  ;
    2107    2107   00868                  ; de routine gebruikt alleen de registers r3,r2,r1,r0 van de huidige bank
    2108    2108   00868                  ;
    2109    2109   00868                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    2110    2110   00868                  
    2111    2111   00868 C0E0             hexbcd16:     push   acc                  ;registers effe bewaren op de stack
    2112    2112   0086A C0D0                           push   psw
    2113    2113   0086C                  
    2114    2114   0086C C077                           push   h7                   ;nodig
    2115    2115   0086E C078                           push   h8
    2116    2116   00870                  
    2117    2117   00870 C079                           push   h9                   ;ook
    2118    2118   00872                  
    2119    2119   00872 757905                         mov    h9,#005h             ;loopcounter
    2120    2120   00875                  
    2121    2121   00875 7B00             hexbcd161:    mov    r3,#000h
    2122    2122   00877 7A0A                           mov    r2,#00ah             ;hierdoor delen we
    2123    2123   00879 120797                         lcall  div16                ;deling uitvoeren
    2124    2124   0087C E8                             mov    a,r0                 ;rest
    2125    2125   0087D C0E0                           push   acc                  ;op stack zetten
    2126    2126   0087F EA                             mov    a,r2
    2127    2127   00880 F8                             mov    r0,a
    2128    2128   00881 EB                             mov    a,r3
    2129    2129   00882 F9                             mov    r1,a                 ;uitkomst terug delen
    2130    2130   00883 D579EF                         djnz   h9,hexbcd161
    2131    2131   00886                  
    2132    2132   00886 D0E0                           pop    acc                  ;hoogste bits van de stack
    2133    2133   00888 FA                             mov    r2,a                 ;klaar
    2134    2134   00889 D0E0                           pop    acc
    2135    2135   0088B C4                             swap   a
    2136    2136   0088C F579                           mov    h9,a
    2137    2137   0088E D0E0                           pop    acc
    2138    2138   00890 2579                           add    a,h9
    2139    2139   00892 F9                             mov    r1,a                 ;volgende 8 klaar
    2140    2140   00893 D0E0                           pop    acc
    2141    2141   00895 C4                             swap   a
    2142    2142   00896 F579                           mov    h9,a
    2143    2143   00898 D0E0                           pop    acc
    2144    2144   0089A 2579                           add    a,h9
    2145    2145   0089C F8                             mov    r0,a                 ;klaar
    2146    2146   0089D                  
    2147    2147   0089D D079                           pop    h9                   ;was naar de knoppen
    2148    2148   0089F                  
    2149    2149   0089F D078                           pop    h8                   ;gebruikt
    2150    2150   008A1 D077                           pop    h7
    2151    2151   008A3                  
    2152    2152   008A3 D0D0                           pop    psw                  ;registers herstellen
    2153    2153   008A5 D0E0                           pop    acc
    2154    2154   008A7 22                             ret
    2155    2155   008A8                  
    2156    2156   008A8                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    2157    2157   008A8                  ;
    2158    2158   008A8                  ; hexbcd8     zet een 8 bit hex getal om in een 8 bit bcd getal
    2159    2159   008A8                  ; input       a (maximale waarde = 63h)
    2160    2160   008A8                  ; output      a
    2161    2161   008A8                  ;
    2162    2162   008A8                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    2163    2163   008A8                  
    2164    2164   008A8 C0D0             hexbcd8:      push   psw                  ;registers op stack zetten
    2165    2165   008AA C0F0                           push   b
    2166    2166   008AC 75F00A                         mov    b,#00ah              ;hierdoor delen
    2167    2167   008AF 84                             div    ab                   ;in accu qoutient in b rest
    2168    2168   008B0 C4                             swap   a
    2169    2169   008B1 25F0                           add    a,b                  ;bcd getal klaar
    2170    2170   008B3 D0F0                           pop    b
    2171    2171   008B5 D0D0                           pop    psw
    2172    2172   008B7 22                             ret
    2173    2173   008B8                  
    2174    2174   008B8                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    2175    2175   008B8                  ;
    2176    2176   008B8                  ; bcdhex16    zal een 16 bit bcd getal omzetten naar een hex getal.
    2177    2177   008B8                  ; input:       r1,r0 = 16 bit bcd getal (r1=msb)
    2178    2178   008B8                  ; output:      r1,r0 = 16 bit hex getal (r1=msb)
    2179    2179   008B8                  ;
    2180    2180   008B8                  ; de routine gebruikt r1,r0 van de huidige bank
    2181    2181   008B8                  ;
    2182    2182   008B8                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    2183    2183   008B8                  
    2184    2184   008B8 C0F0             bcdhex16:     push   b                    ;hebben we nodig
    2185    2185   008BA C0E0                           push   acc
    2186    2186   008BC C0D0                           push   psw
    2187    2187   008BE                  
    2188    2188   008BE E8                             mov    a,r0
    2189    2189   008BF 540F                           anl    a,#00fh              ;eenheden
    2190    2190   008C1 C0E0                           push   acc                  ;effe bewaren
    2191    2191   008C3                  
    2192    2192   008C3 E8                             mov    a,r0
    2193    2193   008C4 C4                             swap   a
    2194    2194   008C5 540F                           anl    a,#00fh              ;tientallen
    2195    2195   008C7 75F00A                         mov    b,#00ah              ;waarde berekenen
    2196    2196   008CA A4                             mul    ab                   ;klaar
    2197    2197   008CB D0F0                           pop    b                    ;truukje
    2198    2198   008CD 25F0                           add    a,b                  ;a is lage deel hex getal
    2199    2199   008CF C0E0                           push   acc                  ;straks nodig
    2200    2200   008D1                  
    2201    2201   008D1 E9                             mov    a,r1                 ;hoge deel
    2202    2202   008D2 54F0                           anl    a,#0f0h
    2203    2203   008D4 C4                             swap   a
    2204    2204   008D5 C0E0                           push   acc                  ;straks nodig
    2205    2205   008D7                  
    2206    2206   008D7 E9                             mov    a,r1
    2207    2207   008D8 540F                           anl    a,#00fh              ;gaan we verder bewerken
    2208    2208   008DA 75F064                         mov    b,#100               ;waarde uitrekenen
    2209    2209   008DD A4                             mul    ab
    2210    2210   008DE A9F0                           mov    r1,b
    2211    2211   008E0 F8                             mov    r0,a
    2212    2212   008E1                  
    2213    2213   008E1 D0E0                           pop    acc
    2214    2214   008E3 75F00A                         mov    b,#10
    2215    2215   008E6 A4                             mul    ab                   ;kan nog in a
    2216    2216   008E7 75F064                         mov    b,#100               ;*10*100=*1000
    2217    2217   008EA A4                             mul    ab
    2218    2218   008EB 28                             add    a,r0
    2219    2219   008EC F8                             mov    r0,a
    2220    2220   008ED E9                             mov    a,r1
    2221    2221   008EE 35F0                           addc   a,b
    2222    2222   008F0 F9                             mov    r1,a
    2223    2223   008F1                  
    2224    2224   008F1 D0E0                           pop    acc
    2225    2225   008F3 28                             add    a,r0
    2226    2226   008F4 F8                             mov    r0,a
    2227    2227   008F5 7400                           mov    a,#000h
    2228    2228   008F7 39                             addc   a,r1
    2229    2229   008F8 F9                             mov    r1,a                 ;klaar
    2230    2230   008F9                  
    2231    2231   008F9 D0D0                           pop    psw
    2232    2232   008FB D0E0                           pop    acc
    2233    2233   008FD D0F0                           pop    b
    2234    2234   008FF 22                             ret
    2235    2235   00900                  
    2236    2236   00900                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    2237    2237   00900                  ;
    2238    2238   00900                  ; bcdhex8     zal een 8 bit bcd getal omzetten naar een hex getal.
    2239    2239   00900                  ; input:      a (maximale waarde 99h)
    2240    2240   00900                  ; output:     a
    2241    2241   00900                  ;
    2242    2242   00900                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    2243    2243   00900                  
    2244    2244   00900 C0D0             bcdhex8:      push   psw                  ;registers op de stack zetten
    2245    2245   00902 C0F0                           push   b
    2246    2246   00904 C070                           push   h0
    2247    2247   00906 F570                           mov    h0,a                 ;effe bewaren
    2248    2248   00908 53700F                         anl    h0,#00fh             ;alleen 4 laagste bits
    2249    2249   0090B 54F0                           anl    a,#0f0h              ;hier alleen 4 hoogste bits
    2250    2250   0090D C4                             swap   a
    2251    2251   0090E 75F00A                         mov    b,#00ah              ;berekenen waarde 4 hoogste bits
    2252    2252   00911 A4                             mul    ab
    2253    2253   00912 2570                           add    a,h0                 ;eenheden bijtellen
    2254    2254   00914 D070                           pop    h0
    2255    2255   00916 D0F0                           pop    b
    2256    2256   00918 D0D0                           pop    psw
    2257    2257   0091A 22                             ret
    2258    2258   0091B                  
    2259    2259   0091B                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    2260    2260   0091B                  ;
    2261    2261   0091B                  ; xcsw2xtal          schakeld overvan de inwendige oscillator naar een extern kristal.
    2262    2262   0091B                  ;
    2263    2263   0091B                  ; Gebruikt geen registers
    2264    2264   0091B                  ;
    2265    2265   0091B                  ; Originele auteur: Danny Pawels (dp)
    2266    2266   0091B                  ;
    2267    2267   0091B                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    2268    2268   0091B                  
    2269    2269   0091B                  
    2270    2270   0091B C083             XCsw2xtal:  push  dph
    2271    2271   0091D C082                         push  dpl
    2272    2272   0091F C0D0                         push  psw
    2273    2273   00921 C08F                         push  syscon0
    2274    2274   00923 C0B2                         push  port_page
    2275    2275   00925 C0BF                         push  scu_page
    2276    2276   00927                  
    2277    2277   00927 758F04                       mov   syscon0,#04h            ;selecteer RMAP0
    2278    2278   0092A 75BF01                       mov   scu_page,#1             ;page 1 van SCU selecteren
    2279    2279   0092D                  
    2280    2280   0092D 43B708                       orl   pll_con,#00001000b      ;VCOBYP=1  bypass de PLL
    2281    2281   00930                                                            ;freq= VCO-free running =5MHz...20MHz?
    2282    2282   00930 43B704                       orl   pll_con,#00000100b      ;OSCDISC=1 disconnect osc. en PLL
    2283    2283   00933 53B6F7                       anl   osc_con,#11110111b      ;XPD=0  externe osc. power-up
    2284    2284   00936 43B604                       orl   osc_con,#00000100b      ;OSCSS=1 externe oscillator selecteren
    2285    2285   00939                  
    2286    2286   00939 90F000                       mov   dptr,#0f000h            ;wacht tot externe osc stabiel is...
    2287    2287   0093C A3               XCsw2xtal0: inc   dptr
    2288    2288   0093D E582                         mov   a,dpl
    2289    2289   0093F 4583                         orl   a,dph
    2290    2290   00941 70F9                         jnz   XCsw2xtal0
    2291    2291   00943                  
    2292    2292   00943 43B602           XCsw2xtal1: orl   osc_con,#00000010b      ;ORDRES=1 osc run detectie starten
    2293    2293   00946                  
    2294    2294   00946                  ;wacht,...dit kan lang duren... tot >2048 VCO cycli...
    2295    2295   00946 E5B6             XCsw2xtal2: mov   a,osc_con               ;check OSCR en ORDRES bits (2 LSB's osc_con)
    2296    2296   00948 20E1FB                       jb    acc.1,XCsw2xtal2        ;Osc.RunDETect klaar? ='0'
    2297    2297   0094B                  ;Oscillator run detectie is klaar...
    2298    2298   0094B 30E0F5                       jnb    acc.0,XCsw2xtal1       ;OSCR=1? ja, dan oscillator running...
    2299    2299   0094E                  
    2300    2300   0094E                  
    2301    2301   0094E E5B7                         mov   a,pll_con               ;lees pll_con
    2302    2302   00950 540F                         anl   a,#0fh                  ;maskeer onderste bits
    2303    2303   00952 44A0                         orl   a,#10100000b            ;stel NDIV in op 1010=waarde 24
    2304    2304   00954                  ;OPGELET: het password moet worden gegeven, dan kan er gedurende 32cclk cycli naar
    2305    2305   00954                  ;beveiligde locaties worden geschreven zoals NDIV en KDIV van de PLL, de watchdog
    2306    2306   00954                  ;enable bit WDTEN en de power-down en slow down enable bits PD en SD !!!!
    2307    2307   00954 75BB98                       mov   passwd,#98h             ;het is nodig het password in te stellen!!!
    2308    2308   00957                                                            ;bij aanpassing van de NDIV van de PLL
    2309    2309   00957 F5B7                         mov   pll_con,a               ;N=24 is nodig bij een 8MHz xtal
    2310    2310   00959 53B7FB                       anl   pll_con,#11111011b      ;OSCDISC=0 connect osc en PLL
    2311    2311   0095C 43B702                       orl   pll_con,#00000010b      ;RESLD=1 restart PLL lock detection
    2312    2312   0095F                  
    2313    2313   0095F E5B7             XCsw2xtal3: mov   a,pll_con               ;check de LOCK bit (lsb van dit register)
    2314    2314   00961 20E0FB                       jb    acc.0,XCsw2xtal3        ;ga pas verder als PLL gelocked is op osc.
    2315    2315   00964                  
    2316    2316   00964 53B7F7                       anl   pll_con,#11110111b      ;VCOBYP=0 fsys is PLL gelockte frequentie.
    2317    2317   00967 43B610                       orl   osc_con,#00010000b      ;OSCPD=1 interne osc. power-down
    2318    2318   0096A                  
    2319    2319   0096A D0BF                         pop   scu_page                ;herstel controller status
    2320    2320   0096C D0B2                         pop   port_page
    2321    2321   0096E D08F                         pop   syscon0
    2322    2322   00970 D0D0                         pop   psw
    2323    2323   00972 D082                         pop   dpl
    2324    2324   00974 D083                         pop   dph
    2325    2325   00976 22                           ret
    2326    2326   00977                  
    2327    2327   00977                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    2328    2328   00977                  ;
    2329    2329   00977                  ; mapregs	selecteer de SFR's in de mapped area
    2330    2330   00977                  ;
    2331    2331   00977                  ;
    2332    2332   00977                  ; Past syscon SFR aan
    2333    2333   00977                  ;
    2334    2334   00977                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    2335    2335   00977                  
    2336    2336   00977 438F01           mapregs:	orl   syscon0,#00000001b	;set bit rmap
    2337    2337   0097A 22               		ret
    2338    2338   0097B                  
    2339    2339   0097B                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    2340    2340   0097B                  ;
    2341    2341   0097B                  ; nomapregs	selecteer de SFR's in de non-mapped area
    2342    2342   0097B                  ;
    2343    2343   0097B                  ; Past syscon SFR aan
    2344    2344   0097B                  ;
    2345    2345   0097B                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    2346    2346   0097B                  
    2347    2347   0097B 538FFE           nomapregs:  anl    syscon0,#11111110b	;clear bit rmap
    2348    2348   0097E 22               		ret
    2349    2349   0097F                  
    2350    2350   0097F                  ;*******************************************************************************
    2351    2351   0097F                  ;
    2352    2352   0097F                  ; These are the register declarations for the XC888 microcontroller from
    2353    2353   0097F                  ; Infineon.
    2354    2354   0097F                  ;
    2355    2355   0097F                  ;*******************************************************************************
    2356    2356   0097F                  
    2357    2357   0097F                  ;*******************************************************************************
    2358    2358   0097F                  ;
    2359    2359   0097F                  ; CPU registers are accessible independend of paging and mapping
    2360    2360   0097F                  ; (always accessible)
    2361    2361   0097F                  ;
    2362    2362   0097F                  ;*******************************************************************************
    2363    2363   0097F                  
    2364    2364   0097F                  sp            data   081h          ;stack pointer                     reset=007h
    2365    2365   0097F                  dpl           data   082h          ;datapointer low register          reset=000h
    2366    2366   0097F                  dph           data   083h          ;datapointer high register         reset=000h
    2367    2367   0097F                  pcon          data   087h          ;power control                     reset=000h
    2368    2368   0097F                  tcon          data   088h          ;timer 0-1 control                 reset=000h
    2369    2369   0097F                  ;tcon is bit addressable
    2370    2370   0097F                         tf1    bit    08fh
    2371    2371   0097F                         tr1    bit    08eh
    2372    2372   0097F                         tf0    bit    08dh
    2373    2373   0097F                         tr0    bit    08ch
    2374    2374   0097F                         ie1    bit    08bh
    2375    2375   0097F                         it1    bit    08ah
    2376    2376   0097F                         ie0    bit    089h
    2377    2377   0097F                         it0    bit    088h
    2378    2378   0097F                  
    2379    2379   0097F                  tmod          data   089h          ;timer 0-1 mode                    reset=000h
    2380    2380   0097F                  tl0           data   08ah          ;timer 0 low                       reset=000h
    2381    2381   0097F                  tl1           data   08bh          ;timer 1 low                       reset=000h
    2382    2382   0097F                  th0           data   08ch          ;timer 0 high                      reset=000h
    2383    2383   0097F                  th1           data   08dh          ;timer 1 high                      reset=000h
    2384    2384   0097F                  
    2385    2385   0097F                  syscon0       data   08fh          ;system control register 0         reset=004h
    2386    2386   0097F                  scon          data   098h          ;serial channel 0 control          reset=000h
    2387    2387   0097F                  ;scon is bit addressable
    2388    2388   0097F                         sm0    bit    09fh
    2389    2389   0097F                         sm1    bit    09eh
    2390    2390   0097F                         sm2    bit    09dh
    2391    2391   0097F                         ren    bit    09ch
    2392    2392   0097F                         tb8    bit    09bh
    2393    2393   0097F                         rb8    bit    09ah
    2394    2394   0097F                         ti     bit    099h
    2395    2395   0097F                         ri     bit    098h
    2396    2396   0097F                  
    2397    2397   0097F                  sbuf          data   099h          ;serial data buffer channel 0
    2398    2398   0097F                  eo            data   0a2h          ;extended operation                reset=000h
    2399    2399   0097F                  ien0          data   0a8h          ;interrupt enable 0                reset=000h
    2400    2400   0097F                  ;ien0 is bit addressable
    2401    2401   0097F                         ea     bit    0afh
    2402    2402   0097F                                                     ;bit not implemented
    2403    2403   0097F                         et2    bit    0adh
    2404    2404   0097F                         es     bit    0ach
    2405    2405   0097F                         et1    bit    0abh
    2406    2406   0097F                         ex1    bit    0aah
    2407    2407   0097F                         et0    bit    0a9h
    2408    2408   0097F                         ex0    bit    0a8h
    2409    2409   0097F                  
    2410    2410   0097F                  ip            data   0b8h          ;interrupt priotity                reset=000h
    2411    2411   0097F                  ;ip is bit addressable
    2412    2412   0097F                                                     ;bit not implemented
    2413    2413   0097F                                                     ;bit not implemented
    2414    2414   0097F                         pt2    bit    0bdh
    2415    2415   0097F                         ps     bit    0bch
    2416    2416   0097F                         pt1    bit    0bbh
    2417    2417   0097F                         px1    bit    0bah
    2418    2418   0097F                         pt0    bit    0b9h
    2419    2419   0097F                         px0    bit    0b8h
    2420    2420   0097F                  
    2421    2421   0097F                  iph           data   0b9h          ;interrupt priority high           reset=000h
    2422    2422   0097F                  psw           data   0d0h          ;program status word               reset=000h
    2423    2423   0097F                  ;psw is bit addressable
    2424    2424   0097F                         cy     bit    0d7h
    2425    2425   0097F                         ac     bit    0d6h
    2426    2426   0097F                         f0     bit    0d5h
    2427    2427   0097F                         rs1    bit    0d4h
    2428    2428   0097F                         rs0    bit    0d3h
    2429    2429   0097F                         ov     bit    0d2h
    2430    2430   0097F                         f1     bit    0d1h
    2431    2431   0097F                         p      bit    0d0h
    2432    2432   0097F                  
    2433    2433   0097F                  acc           data   0e0h          ;accumulator                       reset=000h
    2434    2434   0097F                  ;acc is bit addressable
    2435    2435   0097F                  
    2436    2436   0097F                  ien1          data   0e8h          ;interrupt enable 1                reset=000h
    2437    2437   0097F                  ;ien1 is bit addressable
    2438    2438   0097F                         eccip3 bit    0efh
    2439    2439   0097F                         eccip2 bit    0eeh
    2440    2440   0097F                         eccip1 bit    0edh
    2441    2441   0097F                         eccip0 bit    0ech
    2442    2442   0097F                         exm    bit    0ebh
    2443    2443   0097F                         ex2    bit    0eah
    2444    2444   0097F                         essc   bit    0e9h
    2445    2445   0097F                         eadc   bit    0e8h
    2446    2446   0097F                  
    2447    2447   0097F                  b             data   0f0h          ;b register                        reset=000h
    2448    2448   0097F                  ;b is bit addressable
    2449    2449   0097F                  
    2450    2450   0097F                  ip1           data   0f8h          ;interrupt priority 1              reset=000h
    2451    2451   0097F                  ;ip1 is bit addressable
    2452    2452   0097F                         pccip3 bit    0ffh
    2453    2453   0097F                         pccip2 bit    0feh
    2454    2454   0097F                         pccip1 bit    0fdh
    2455    2455   0097F                         pccip0 bit    0fch
    2456    2456   0097F                         pxm    bit    0fbh
    2457    2457   0097F                         px2    bit    0fah
    2458    2458   0097F                         pssc   bit    0f9h
    2459    2459   0097F                         padc   bit    0f8h
    2460    2460   0097F                  
    2461    2461   0097F                  iph1          data   0f9h          ;interrupt priority 1 high         reset=000h
    2462    2462   0097F                  
    2463    2463   0097F                  
    2464    2464   0097F                  ;*******************************************************************************
    2465    2465   0097F                  ;
    2466    2466   0097F                  ; system control registers registers that can only be accessed in the non
    2467    2467   0097F                  ; mapped memory area (rmap=0) page independent
    2468    2468   0097F                  ;
    2469    2469   0097F                  ;*******************************************************************************
    2470    2470   0097F                  
    2471    2471   0097F                  scu_page      data   0bfh          ;page register scu                 reset=000h
    2472    2472   0097F                  
    2473    2473   0097F                  ;*******************************************************************************
    2474    2474   0097F                  ;
    2475    2475   0097F                  ; system control registers registers that can only be accessed in the non
    2476    2476   0097F                  ; mapped memory area (rmap=0) and page 0
    2477    2477   0097F                  ;
    2478    2478   0097F                  ;*******************************************************************************
    2479    2479   0097F                  
    2480    2480   0097F                  modpisel      data   0b3h          ;peripheral input select           reset=000h
    2481    2481   0097F                  ircon0        data   0b4h          ;interrupt request register        reset=000h
    2482    2482   0097F                  ircon1        data   0b5h          ;interrupt request register        reset=000h
    2483    2483   0097F                  ircon2        data   0b6h          ;interrupt request register        reset=000h
    2484    2484   0097F                  exicon0       data   0b7h          ;external interrupt control        reset=0f0h
    2485    2485   0097F                  exicon1       data   0bah          ;external interrupt control        reset=03fh
    2486    2486   0097F                  nmicon        data   0bbh          ;nimi control                      reset=000h
    2487    2487   0097F                  nmisr         data   0bch          ;nmi status                        reset=000h
    2488    2488   0097F                  bcon          data   0bdh          ;baud rate control                 reset=000h
    2489    2489   0097F                  bg            data   0beh          ;baud rate timer reload            reset=000h
    2490    2490   0097F                  fdcon         data   0e9h          ;fractional devider control        reset=000h
    2491    2491   0097F                  fdstep        data   0eah          ;fractional devider reload         reset=000h
    2492    2492   0097F                  fdres         data   0ebh          ;fractional divider result         reset=000h
    2493    2493   0097F                  
    2494    2494   0097F                  ;*******************************************************************************
    2495    2495   0097F                  ;
    2496    2496   0097F                  ; system control registers registers that can only be accessed in the non
    2497    2497   0097F                  ; mapped memory area (rmap=0) and page 1
    2498    2498   0097F                  ;
    2499    2499   0097F                  ;*******************************************************************************
    2500    2500   0097F                  
    2501    2501   0097F                  id            data   0b3h          ;identity register     reset=device dependent
    2502    2502   0097F                  pmcon0        data   0b4h          ;power mode control                reset=000h
    2503    2503   0097F                  pmcon1        data   0b5h          ;power mode control                reset=000h
    2504    2504   0097F                  osc_con       data   0b6h          ;osc control                       reset=008h
    2505    2505   0097F                  pll_con       data   0b7h          ;pll control                       reset=090h
    2506    2506   0097F                  cmcon         data   0bah          ;clock control                     reset=010h
    2507    2507   0097F                  passwd        data   0bbh          ;password register                 reset=007h
    2508    2508   0097F                  feal          data   0bch          ;flash error register              reset=000h
    2509    2509   0097F                  feah          data   0bdh          ;flash error address high          reset=000h
    2510    2510   0097F                  cocon         data   0beh          ;clock output control              reset=000h
    2511    2511   0097F                  misc_con      data   0e9h          ;miscellaneous control             reset=000h
    2512    2512   0097F                  
    2513    2513   0097F                  ;*******************************************************************************
    2514    2514   0097F                  ;
    2515    2515   0097F                  ; system control registers registers that can only be accessed in the non
    2516    2516   0097F                  ; mapped memory area (rmap=0) and page 3
    2517    2517   0097F                  ;
    2518    2518   0097F                  ;*******************************************************************************
    2519    2519   0097F                  
    2520    2520   0097F                  xaddrh        data   0b3h          ;on chip xram address high         reset=0f0h
    2521    2521   0097F                  ircon3        data   0b4h          ;interrupt request register        reset=000h
    2522    2522   0097F                  ircon4        data   0b5h          ;interrupt request register        reset=000h
    2523    2523   0097F                  modpisel1     data   0b7h          ;peripheral input select 1         reset=000h
    2524    2524   0097F                  modpisel2     data   0bah          ;peripheral input select 2         reset=000h
    2525    2525   0097F                  pmcon2        data   0bbh          ;power mode control 2              reset=000h
    2526    2526   0097F                  modsusp       data   0bdh          ;mudule suspend control            reset=001h
    2527    2527   0097F                  
    2528    2528   0097F                  ;*******************************************************************************
    2529    2529   0097F                  ;
    2530    2530   0097F                  ; port registers accessed in non mapped memory area (rmap=0) page independent
    2531    2531   0097F                  ;
    2532    2532   0097F                  ;*******************************************************************************
    2533    2533   0097F                  
    2534    2534   0097F                  port_page     data   0b2h          ;port page register                reset=000h
    2535    2535   0097F                  
    2536    2536   0097F                  ;*******************************************************************************
    2537    2537   0097F                  ;
    2538    2538   0097F                  ; port registers accessed in non mapped memory area (rmap=0) page 0
    2539    2539   0097F                  ;
    2540    2540   0097F                  ;*******************************************************************************
    2541    2541   0097F                  
    2542    2542   0097F                  p0_data       data   080h          ;port 0 data register              reset=000h
    2543    2543   0097F                  ;p0_data is bit addressable
    2544    2544   0097F                  p0_dir        data   086h          ;port 0 direction register         reset=000h
    2545    2545   0097F                  p1_data       data   090h          ;port 1 data register              reset=000h
    2546    2546   0097F                  ;p1_data is bit addressable
    2547    2547   0097F                  p1_dir        data   091h          ;port 1 direction register         reset=000h
    2548    2548   0097F                  p2_data       data   0a0h          ;port 2 data register              reset=000h
    2549    2549   0097F                  ;p2_data is bit addressable
    2550    2550   0097F                  p2_dir        data   0a1h          ;port 2 direction register         reset=000h
    2551    2551   0097F                  p3_data       data   0b0h          ;port 3 data register              reset=000h
    2552    2552   0097F                  ;p3_data is bit addressable
    2553    2553   0097F                  p3_dir        data   0b1h          ;port 3 direction register         reset=000h
    2554    2554   0097F                  p4_data       data   0c8h          ;port 4 data register              reset=000h
    2555    2555   0097F                  ;p4_data is bit addressable
    2556    2556   0097F                  p4_dir        data   0c9h          ;port 4 direction register         reset=000h
    2557    2557   0097F                  p5_data       data   092h          ;port 5 data register              reset=000h
    2558    2558   0097F                  p5_dir        data   093h          ;port 5 direction register         reset=000h
    2559    2559   0097F                  
    2560    2560   0097F                  ;*******************************************************************************
    2561    2561   0097F                  ;
    2562    2562   0097F                  ; port registers accessed in non mapped memory area (rmap=0) page 1
    2563    2563   0097F                  ;
    2564    2564   0097F                  ;*******************************************************************************
    2565    2565   0097F                  
    2566    2566   0097F                  p0_pudsel     data   080h          ;port 0 pull-up/down select        reset=0ffh
    2567    2567   0097F                  ;p0_data is bit addressable
    2568    2568   0097F                  p0_puden      data   086h          ;port 0 pull-up/down enable        reset=0c4h
    2569    2569   0097F                  p1_pudsel     data   090h          ;port 1 pull-up/down select        reset=0ffh
    2570    2570   0097F                  ;p1_data is bit addressable
    2571    2571   0097F                  p1_puden      data   091h          ;port 1 pull-up/down enable        reset=0ffh
    2572    2572   0097F                  p2_pudsel     data   0a0h          ;port 2 pull-up/down select        reset=0ffh
    2573    2573   0097F                  ;p2_data is bit addressable
    2574    2574   0097F                  p2_puden      data   0a1h          ;port 2 pull-up/down enable        reset=000h
    2575    2575   0097F                  p3_pudsel     data   0b0h          ;port 3 pull-up/down select        reset=0bfh
    2576    2576   0097F                  ;p3_data is bit addressable
    2577    2577   0097F                  p3_puden      data   0b1h          ;port 3 pull-up/down enable        reset=040h
    2578    2578   0097F                  p4_pudsel     data   0c8h          ;port 4 pull-up/down select        reset=0ffh
    2579    2579   0097F                  ;p4_data is bit addressable
    2580    2580   0097F                  p4_puden      data   0c9h          ;port 4 pull-up/down enable        reset=004h
    2581    2581   0097F                  p5_pudsel     data   092h          ;port 5 pull-up/down select        reset=0ffh
    2582    2582   0097F                  p5_puden      data   093h          ;port 5 pull-up/down enable        reset=0ffh
    2583    2583   0097F                  
    2584    2584   0097F                  ;*******************************************************************************
    2585    2585   0097F                  ;
    2586    2586   0097F                  ; port registers accessed in non mapped memory area (rmap=0) page 2
    2587    2587   0097F                  ;
    2588    2588   0097F                  ;*******************************************************************************
    2589    2589   0097F                  
    2590    2590   0097F                  p0_altsel0    data   080h          ;port 0 alternate select           reset=000h
    2591    2591   0097F                  ;p0_data is bit addressable
    2592    2592   0097F                  p0_altsel1    data   086h          ;port 0 alternate select           reset=000h
    2593    2593   0097F                  p1_altsel0    data   090h          ;port 1 alternate select           reset=000h
    2594    2594   0097F                  ;p1_data is bit addressable
    2595    2595   0097F                  p1_altsel1    data   091h          ;port 1 alternate select           reset=000h
    2596    2596   0097F                  p3_altsel0    data   0b0h          ;port 3 alternate select           reset=000h
    2597    2597   0097F                  ;p3_data is bit addressable
    2598    2598   0097F                  p3_altsel1    data   0b1h          ;port 3 alternate select           reset=000h
    2599    2599   0097F                  p4_altsel0    data   0c8h          ;port 4 alternate select           reset=000h
    2600    2600   0097F                  ;p4_data is bit addressable
    2601    2601   0097F                  p4_altsel1    data   0c9h          ;port 4 alternate select           reset=000h
    2602    2602   0097F                  p5_altsel0    data   092h          ;port 5 alternate select           reset=000h
    2603    2603   0097F                  p5_altsel1    data   093h          ;port 5 alternate select           reset=000h
    2604    2604   0097F                  
    2605    2605   0097F                  ;*******************************************************************************
    2606    2606   0097F                  ;
    2607    2607   0097F                  ; port registers accessed in non mapped memory area (rmap=0) page 3
    2608    2608   0097F                  ;
    2609    2609   0097F                  ;*******************************************************************************
    2610    2610   0097F                  
    2611    2611   0097F                  p0_od         data   080h          ;port 0 open drain control         reset=000h
    2612    2612   0097F                  ;p0_data is bit addressable
    2613    2613   0097F                  p1_od         data   090h          ;port 0 open drain control         reset=000h
    2614    2614   0097F                  ;p1_data is bit addressable
    2615    2615   0097F                  p3_od         data   0b0h          ;port 0 open drain control         reset=000h
    2616    2616   0097F                  ;p3_data is bit addressable
    2617    2617   0097F                  p4_od         data   0c8h          ;port 0 open drain control         reset=000h
    2618    2618   0097F                  ;p4_data is bit addressable
    2619    2619   0097F                  p5_od         data   092h          ;port 0 open drain control         reset=000h
    2620    2620   0097F                  
    2621    2621   0097F                  ;*******************************************************************************
    2622    2622   0097F                  ;
    2623    2623   0097F                  ; adc registers accessed in non mapped memory area (rmap=0) page independent
    2624    2624   0097F                  ;
    2625    2625   0097F                  ;*******************************************************************************
    2626    2626   0097F                  
    2627    2627   0097F                  adc_page      data   0d1h          ;adc page register                 reset=000h
    2628    2628   0097F                  
    2629    2629   0097F                  ;*******************************************************************************
    2630    2630   0097F                  ;
    2631    2631   0097F                  ; adc registers accessed in non mapped memory area (rmap=0) page 0
    2632    2632   0097F                  ;
    2633    2633   0097F                  ;*******************************************************************************
    2634    2634   0097F                  
    2635    2635   0097F                  adc_globctr   data   0cah          ;global control register           reset=030h
    2636    2636   0097F                  adc_globstr   data   0cbh          ;global status register            reset=000h
    2637    2637   0097F                  adc_prar      data   0cch          ;priority and arbitration          reset=000h
    2638    2638   0097F                  adc_lcbr      data   0cdh          ;limit check boundary              reset=0b7h
    2639    2639   0097F                  adc_inpcr0    data   0ceh          ;input class 0 register            reset=000h
    2640    2640   0097F                  adc_etrcr     data   0cfh          ;external trigger control          reset=000h
    2641    2641   0097F                  
    2642    2642   0097F                  ;*******************************************************************************
    2643    2643   0097F                  ;
    2644    2644   0097F                  ; adc registers accessed in non mapped memory area (rmap=0) page 1
    2645    2645   0097F                  ;
    2646    2646   0097F                  ;*******************************************************************************
    2647    2647   0097F                  
    2648    2648   0097F                  adc_chctr0    data   0cah          ;channel control register          reset=000h
    2649    2649   0097F                  adc_chctr1    data   0cbh          ;channel control register          reset=000h
    2650    2650   0097F                  adc_chctr2    data   0cch          ;channel control register          reset=000h
    2651    2651   0097F                  adc_chctr3    data   0cdh          ;channel control register          reset=000h
    2652    2652   0097F                  adc_chctr4    data   0ceh          ;channel control register          reset=000h
    2653    2653   0097F                  adc_chctr5    data   0cfh          ;channel control register          reset=000h
    2654    2654   0097F                  adc_chctr6    data   0d2h          ;channel control register          reset=000h
    2655    2655   0097F                  adc_chctr7    data   0d3h          ;channel control register          reset=000h
    2656    2656   0097F                  
    2657    2657   0097F                  ;*******************************************************************************
    2658    2658   0097F                  ;
    2659    2659   0097F                  ; adc registers accessed in non mapped memory area (rmap=0) page 2
    2660    2660   0097F                  ;
    2661    2661   0097F                  ;*******************************************************************************
    2662    2662   0097F                  
    2663    2663   0097F                  adc_resr0l    data   0cah          ;result register 0 low             reset=000h
    2664    2664   0097F                  adc_resr0h    data   0cbh          ;result register 0 high            reset=000h
    2665    2665   0097F                  adc_resr1l    data   0cch          ;result register 1 low             reset=000h
    2666    2666   0097F                  adc_resr1h    data   0cdh          ;result register 1 high            reset=000h
    2667    2667   0097F                  adc_resr2l    data   0ceh          ;result register 2 low             reset=000h
    2668    2668   0097F                  adc_resr2h    data   0cfh          ;result register 2 high            reset=000h
    2669    2669   0097F                  adc_resr3l    data   0d2h          ;result register 3 low             reset=000h
    2670    2670   0097F                  adc_resr3h    data   0d3h          ;result register 3 high            reset=000h
    2671    2671   0097F                  
    2672    2672   0097F                  ;*******************************************************************************
    2673    2673   0097F                  ;
    2674    2674   0097F                  ; adc registers accessed in non mapped memory area (rmap=0) page 3
    2675    2675   0097F                  ;
    2676    2676   0097F                  ;*******************************************************************************
    2677    2677   0097F                  
    2678    2678   0097F                  adc_resra0l   data   0cah          ;result register 0 l view          reset=000h
    2679    2679   0097F                  adc_resra0h   data   0cbh          ;result register 0 h view          reset=000h
    2680    2680   0097F                  adc_resra1l   data   0cch          ;result register 1 l view          reset=000h
    2681    2681   0097F                  adc_resra1h   data   0cdh          ;result register 1 h view          reset=000h
    2682    2682   0097F                  adc_resra2l   data   0ceh          ;result register 2 l view          reset=000h
    2683    2683   0097F                  adc_resra2h   data   0cfh          ;result register 2 h view          reset=000h
    2684    2684   0097F                  adc_resra3l   data   0d2h          ;result register 3 l view          reset=000h
    2685    2685   0097F                  adc_resra3h   data   0d3h          ;result register 3 h view          reset=000h
    2686    2686   0097F                  
    2687    2687   0097F                  ;*******************************************************************************
    2688    2688   0097F                  ;
    2689    2689   0097F                  ; adc registers accessed in non mapped memory area (rmap=0) page 4
    2690    2690   0097F                  ;
    2691    2691   0097F                  ;*******************************************************************************
    2692    2692   0097F                  
    2693    2693   0097F                  adc_rcr0      data   0cah          ;result control register           reset=000h
    2694    2694   0097F                  adc_rcr1      data   0cbh          ;result control register           reset=000h
    2695    2695   0097F                  adc_rcr2      data   0cch          ;result control register           reset=000h
    2696    2696   0097F                  adc_rcr3      data   0cdh          ;result control register           reset=000h
    2697    2697   0097F                  adc_vfcr      data   0ceh          ;valid flag clear register         reset=000h
    2698    2698   0097F                  
    2699    2699   0097F                  ;*******************************************************************************
    2700    2700   0097F                  ;
    2701    2701   0097F                  ; adc registers accessed in non mapped memory area (rmap=0) page 5
    2702    2702   0097F                  ;
    2703    2703   0097F                  ;*******************************************************************************
    2704    2704   0097F                  
    2705    2705   0097F                  adc_chinfr    data   0cah          ;channel interrupt flag register   reset=000h
    2706    2706   0097F                  adc_chincr    data   0cbh          ;channel interrupt clear register  reset=000h
    2707    2707   0097F                  adc_chinsr    data   0cch          ;channel interrupt set register    reset=000h
    2708    2708   0097F                  adc_chinpr    data   0cdh          ;channel interrupt node pointrer   reset=000h
    2709    2709   0097F                  adc_evinfr    data   0ceh          ;event interrupt flag register     reset=000h
    2710    2710   0097F                  adc_evincr    data   0cfh          ;event interrupt clear flag reg.   reset=000h
    2711    2711   0097F                  adc_evinsr    data   0d2h          ;event interrupt set flag register reset=000h
    2712    2712   0097F                  adc_evinpr    data   0d3h          ;event interrupt node pointer reg. reset=000h
    2713    2713   0097F                  
    2714    2714   0097F                  ;*******************************************************************************
    2715    2715   0097F                  ;
    2716    2716   0097F                  ; adc registers accessed in non mapped memory area (rmap=0) page 6
    2717    2717   0097F                  ;
    2718    2718   0097F                  ;*******************************************************************************
    2719    2719   0097F                  
    2720    2720   0097F                  adc_crcr1     data   0cah          ;conversion request control        reset=000h
    2721    2721   0097F                  adc_crpr1     data   0cbh          ;conversion request pending        reset=000h
    2722    2722   0097F                  adc_crmr1     data   0cch          ;conversion request mode           reset=000h
    2723    2723   0097F                  adc_qmr0      data   0cdh          ;queue mode                        reset=000h
    2724    2724   0097F                  adc_qsr0      data   0ceh          ;queue status register             reset=020h
    2725    2725   0097F                  adc_q0r0      data   0cfh          ;queue 0 register 0                reset=000h
    2726    2726   0097F                  adc_qbur0     data   0d2h          ;queue backup register             reset=000h
    2727    2727   0097F                  adc_qinr0     data   0d3h          ;queue input register              reset=000h
    2728    2728   0097F                  
    2729    2729   0097F                  ;*******************************************************************************
    2730    2730   0097F                  
    2731    2731   0097F                  ; timer 2 registers accessed in non mapped memory area (rmap=0)
    2732    2732   0097F                  ;
    2733    2733   0097F                  ;*******************************************************************************
    2734    2734   0097F                  
    2735    2735   0097F                  t2_t2con      data   0c0h          ;timer 2 control register          reset=000h
    2736    2736   0097F                  ;t2_t2con is bit addressable
    2737    2737   0097F                         tf2    bit    0c7h
    2738    2738   0097F                         exf2   bit    0c6h
    2739    2739   0097F                                                     ;2 bits are not implemented
    2740    2740   0097F                         exen2  bit    0c3h
    2741    2741   0097F                         tr2    bit    0c2h
    2742    2742   0097F                         ct2    bit    0c1h
    2743    2743   0097F                         cprl2  bit    0c0h
    2744    2744   0097F                  
    2745    2745   0097F                  t2_t2mod      data   0c1h          ;timer 2 mode register             reset=000h
    2746    2746   0097F                  t2_rc2l       data   0c2h          ;timer 2 reload/capture low        reset=000h
    2747    2747   0097F                  t2_rc2h       data   0c3h          ;timer 2 rel/cap high              reset=000h
    2748    2748   0097F                  t2_t2l        data   0c4h          ;timer 2 register low              reset=000h
    2749    2749   0097F                  t2_t2h        data   0c5h          ;timer 2 register high             reset=000h
    2750    2750   0097F                  
    2751    2751   0097F                  ;*******************************************************************************
    2752    2752   0097F                  ;
    2753    2753   0097F                  ; ccu6 registers are accessed in non mapped memory (rmap=0) page independent
    2754    2754   0097F                  ;
    2755    2755   0097F                  ;*******************************************************************************
    2756    2756   0097F                  
    2757    2757   0097F                  ccu6_page     data   0a3h          ;ccu6 page register                reset=000h
    2758    2758   0097F                  
    2759    2759   0097F                  ;*******************************************************************************
    2760    2760   0097F                  ;
    2761    2761   0097F                  ; ccu6 registers are accessed in non mapped memory (rmap=0) page 0
    2762    2762   0097F                  ;
    2763    2763   0097F                  ;*******************************************************************************
    2764    2764   0097F                  
    2765    2765   0097F                  ccu6_cc63srl  data   09ah          ;cap/comp shadow channel 63        reset=000h
    2766    2766   0097F                  ccu6_cc63srh  data   09bh          ;cap/comp shadow channel 63        reset=000h
    2767    2767   0097F                  ccu6_tctr4l   data   09ch          ;timer control low                 reset=000h
    2768    2768   0097F                  ccu6_tctr4h   data   09dh          ;timer control high                reset=000h
    2769    2769   0097F                  ccu6_mcmoutsl data   09eh          ;multichannel mode output shadow   reset=000h
    2770    2770   0097F                  ccu6_mcmoutsh data   09fh          ;multichannel mode output shadow   reset=000h
    2771    2771   0097F                  ccu6_isrl     data   0a4h          ;cap/com interrupt status          reset=000h
    2772    2772   0097F                  ccu6_isrh     data   0a5h          ;cap/com interrupt status          reset=000h
    2773    2773   0097F                  ccu6_cmpmodifl       data   0a6h   ;compare state modification reg.   reset=000h
    2774    2774   0097F                  ccu6_cmpmodifh       data   0a7h   ;compare state modification reg.   reset=000h
    2775    2775   0097F                  ccu6_cc60srl  data   0fah          ;cap/comp shadow channel 60        reset=000h
    2776    2776   0097F                  ccu6_cc60srh  data   0fbh          ;cap/comp shadow channel 60        reset=000h
    2777    2777   0097F                  ccu6_cc61srl  data   0fch          ;cap/comp shadow channel 61        reset=000h
    2778    2778   0097F                  ccu6_cc61srh  data   0fdh          ;cap/comp shadow channel 61        reset=000h
    2779    2779   0097F                  ccu6_cc62srl  data   0feh          ;cap/comp shadow channel 62        reset=000h
    2780    2780   0097F                  ccu6_cc62srh  data   0ffh          ;cap/comp shadow channel 62        reset=000h
    2781    2781   0097F                  
    2782    2782   0097F                  ;*******************************************************************************
    2783    2783   0097F                  ;
    2784    2784   0097F                  ; ccu6 registers are accessed in non mapped memory (rmap=0) page 1
    2785    2785   0097F                  ;
    2786    2786   0097F                  ;*******************************************************************************
    2787    2787   0097F                  
    2788    2788   0097F                  ccu6_cc63rl   data   09ah          ;cap/comp register channel 63      reset=000h
    2789    2789   0097F                  ccu6_cc63rh   data   09bh          ;cap/comp register channel 63      reset=000h
    2790    2790   0097F                  ccu6_t12prl   data   09ch          ;timer 12 period register          reset=000h
    2791    2791   0097F                  ccu6_t12prh   data   09dh          ;timer 12 period register          reset=000h
    2792    2792   0097F                  ccu6_t13prl   data   09eh          ;timer 13 period register          reset=000h
    2793    2793   0097F                  ccu6_t13prh   data   09fh          ;timer 13 period register          reset=000h
    2794    2794   0097F                  ccu6_t12dtcl  data   0a4h          ;timer 12 dead time control        reset=000h
    2795    2795   0097F                  ccu6_t12dtch  data   0a5h          ;timer 12 dead time control        reset=000h
    2796    2796   0097F                  ccu6_tctr0l   data   0a6h          ;timer control                     reset=000h
    2797    2797   0097F                  ccu6_tctr0h   data   0a7h          ;timer control                     reset=000h
    2798    2798   0097F                  ccu6_cc60rl   data   0fah          ;cap/comp register channel 60      reset=000h
    2799    2799   0097F                  ccu6_cc60rh   data   0fbh          ;cap/comp register channel 60      reset=000h
    2800    2800   0097F                  ccu6_cc61rl   data   0fch          ;cap/comp register channel 61      reset=000h
    2801    2801   0097F                  ccu6_cc61rh   data   0fdh          ;cap/comp register channel 61      reset=000h
    2802    2802   0097F                  ccu6_cc62rl   data   0feh          ;cap/comp register channel 62      reset=000h
    2803    2803   0097F                  ccu6_cc62rh   data   0ffh          ;cap/comp register channel 62      reset=000h
    2804    2804   0097F                  
    2805    2805   0097F                  ;*******************************************************************************
    2806    2806   0097F                  ;
    2807    2807   0097F                  ; ccu6 registers are accessed in non mapped memory (rmap=0) page 2
    2808    2808   0097F                  ;
    2809    2809   0097F                  ;*******************************************************************************
    2810    2810   0097F                  
    2811    2811   0097F                  ccu6_t12msell data   09ah          ;t12 cap/comp mode select          reset=000h
    2812    2812   0097F                  ccu6_t12mselh data   09bh          ;t12 cap/comp mode select          reset=000h
    2813    2813   0097F                  ccu6_ienl     data   09ch          ;cap/comp interrupt enable         reset=000h
    2814    2814   0097F                  ccu6_ienh     data   09dh          ;cap/comp interrupt enable         reset=000h
    2815    2815   0097F                  ccu6_inpl     data   09eh          ;cap/comp interrupt node pointer   reset=040h
    2816    2816   0097F                  ccu6_inph     data   09fh          ;cap/comp interrupt node pointer   reset=039h
    2817    2817   0097F                  ccu6_issl     data   0a4h          ;cap/comp interruopt status        reset=000h
    2818    2818   0097F                  ccu6_issh     data   0a5h          ;cap/comp interruopt status        reset=000h
    2819    2819   0097F                  ccu6_pslr     data   0a6h          ;passive state level register      reset=000h
    2820    2820   0097F                  ccu6_mcmctr   data   0a7h          ;multi channel mode control        reset=000h
    2821    2821   0097F                  ccu6_tctr2l   data   0fah          ;timer control register            reset=000h
    2822    2822   0097F                  ccu6_tctr2h   data   0fbh          ;timer control register            reset=000h
    2823    2823   0097F                  ccu6_modctrl  data   0fch          ;modulation control                reset=000h
    2824    2824   0097F                  ccu6_modctrh  data   0fdh          ;modulation control                reset=000h
    2825    2825   0097F                  ccu6_trpctrl  data   0feh          ;trap control register             reset=000h
    2826    2826   0097F                  ccu6_trpctrh  data   0ffh          ;trap control register             reset=000h
    2827    2827   0097F                  
    2828    2828   0097F                  ;*******************************************************************************
    2829    2829   0097F                  ;
    2830    2830   0097F                  ; ccu6 registers are accessed in non mapped memory (rmap=0) page 3
    2831    2831   0097F                  ;
    2832    2832   0097F                  ;*******************************************************************************
    2833    2833   0097F                  
    2834    2834   0097F                  ccu6_mcmoutl  data   09ah          ;multi channel mode output         reset=000h
    2835    2835   0097F                  ccu6_mcmouth  data   09bh          ;multi channel mode output         reset=000h
    2836    2836   0097F                  ccu6_isl      data   09ch          ;cap/comp interrupt status         reset=000h
    2837    2837   0097F                  ccu6_ish      data   09dh          ;cap/comp interrupt status         reset=000h
    2838    2838   0097F                  ccu6_pisel0l  data   09eh          ;port input selection register     reset=000h
    2839    2839   0097F                  ccu6_pisel0h  data   09fh          ;port input selection register     reset=000h
    2840    2840   0097F                  ccu6_pisel2   data   0a4h          ;port input selection register     reset=000h
    2841    2841   0097F                  ccu6_t12l     data   0fah          ;timer 12 register                 reset=000h
    2842    2842   0097F                  ccu6_t12h     data   0fbh          ;timer 12 register                 reset=000h
    2843    2843   0097F                  ccu6_t13l     data   0fch          ;timer 13 register                 reset=000h
    2844    2844   0097F                  ccu6_t13h     data   0fdh          ;timer 13 register                 reset=000h
    2845    2845   0097F                  ccu6_cmpstatl data   0feh          ;compare state register            reset=000h
    2846    2846   0097F                  ccu6_cmpstath data   0ffh          ;compare state register            reset=000h
    2847    2847   0097F                  
    2848    2848   0097F                  ;*******************************************************************************
    2849    2849   0097F                  ;
    2850    2850   0097F                  ; ssc registers can be accessed in the standard memory map (rmap=0)
    2851    2851   0097F                  ;
    2852    2852   0097F                  ;*******************************************************************************
    2853    2853   0097F                  
    2854    2854   0097F                  ssc_pisel     data   0a9h          ;port input select                 reset=000h
    2855    2855   0097F                  ssc_conl      data   0aah          ;control register programming mode reset=000h
    2856    2856   0097F                  ssc_conh      data   0abh          ;control register programming mode reset=000h
    2857    2857   0097F                  ssc_tbl       data   0ach          ;transmitter buffer                reset=000h
    2858    2858   0097F                  ssc_rbl       data   0adh          ;receiver buffer                   reset=000h
    2859    2859   0097F                  ssc_brl       data   0aeh          ;baud rate timer                   reset=000h
    2860    2860   0097F                  ssc_brh       data   0afh          ;baud rate timer                   reset=000h
    2861    2861   0097F                  
    2862    2862   0097F                  ;*******************************************************************************
    2863    2863   0097F                  ;
    2864    2864   0097F                  ; can registers can be accessed in the standard memory map (rmap=0)
    2865    2865   0097F                  ;
    2866    2866   0097F                  ;*******************************************************************************
    2867    2867   0097F                  
    2868    2868   0097F                  adcon         data   0d8h          ;adres/data control                reset=000h
    2869    2869   0097F                  ; adcon is bit addressable
    2870    2870   0097F                         v3     bit    0dfh
    2871    2871   0097F                         v2     bit    0deh
    2872    2872   0097F                         v1     bit    0ddh
    2873    2873   0097F                         v0     bit    0dch
    2874    2874   0097F                         auad1  bit    0dbh
    2875    2875   0097F                         auad0  bit    0dah
    2876    2876   0097F                         can_bsy bit   0d9h
    2877    2877   0097F                         rwen   bit    0d8h
    2878    2878   0097F                  
    2879    2879   0097F                  adl           data   0d9h          ;adres register low                reset=000h
    2880    2880   0097F                  adh           data   0dah          ;adres register low                reset=000h
    2881    2881   0097F                  data0         data   0dbh          ;can data                          reset=000h
    2882    2882   0097F                  data1         data   0dch          ;can data                          reset=000h
    2883    2883   0097F                  data2         data   0ddh          ;can data                          reset=000h
    2884    2884   0097F                  data3         data   0deh          ;can data                          reset=000h
    2885    2885   0097F                  
    2886    2886   0097F                  ;*******************************************************************************
    2887    2887   0097F                  ;
    2888    2888   0097F                  ; mdu registers can only be accessed in the mapped memory area (rmap=1)
    2889    2889   0097F                  ;
    2890    2890   0097F                  ;*******************************************************************************
    2891    2891   0097F                  
    2892    2892   0097F                  mdustat       data   0b0h          ;mdu status register               reset=000h
    2893    2893   0097F                  ;mdustat is bit addressable
    2894    2894   0097F                                                     ;5 bits are not implemented
    2895    2895   0097F                         bsy    bit    0b2h
    2896    2896   0097F                         ierr   bit    0b1h
    2897    2897   0097F                         irdy   bit    0b0h
    2898    2898   0097F                  
    2899    2899   0097F                  mducon        data   0b1h          ;mdu control                       reset=000h
    2900    2900   0097F                  md0           data   0b2h          ;mdu operand register              reset=000h
    2901    2901   0097F                  mr0           data   0b2h          ;mdu result register               reset=000h
    2902    2902   0097F                  md1           data   0b3h          ;mdu operand register              reset=000h
    2903    2903   0097F                  mr1           data   0b3h          ;mdu result register               reset=000h
    2904    2904   0097F                  md2           data   0b4h          ;mdu operand register              reset=000h
    2905    2905   0097F                  mr2           data   0b4h          ;mdu result register               reset=000h
    2906    2906   0097F                  md3           data   0b5h          ;mdu operand register              reset=000h
    2907    2907   0097F                  mr3           data   0b5h          ;mdu result register               reset=000h
    2908    2908   0097F                  md4           data   0b6h          ;mdu operand register              reset=000h
    2909    2909   0097F                  mr4           data   0b6h          ;mdu result register               reset=000h
    2910    2910   0097F                  md5           data   0b7h          ;mdu operand register              reset=000h
    2911    2911   0097F                  mr5           data   0b7h          ;mdu result register               reset=000h
    2912    2912   0097F                  
    2913    2913   0097F                  ;*******************************************************************************
    2914    2914   0097F                  ;
    2915    2915   0097F                  ; cordic registers can only be accessed in the mapped memory area (rmap=1)
    2916    2916   0097F                  ;
    2917    2917   0097F                  ;*******************************************************************************
    2918    2918   0097F                  
    2919    2919   0097F                  cd_cordxl     data   09ah          ;cordic x data low                 reset=000h
    2920    2920   0097F                  cd_cordxh     data   09bh          ;cordic x data high                reset=000h
    2921    2921   0097F                  cd_cordyl     data   09ch          ;cordic y data low                 reset=000h
    2922    2922   0097F                  cd_cordyh     data   09dh          ;cordic y data high                reset=000h
    2923    2923   0097F                  cd_cordzl     data   09eh          ;cordic z data low                 reset=000h
    2924    2924   0097F                  cd_cordzh     data   09fh          ;cordic z data high                reset=000h
    2925    2925   0097F                  cd_statc      data   0a0h          ;cordic status and control         reset=000h
    2926    2926   0097F                  ;cd_statc is bit addressable
    2927    2927   0097F                         keepz  bit    0a7h
    2928    2928   0097F                         keepy  bit    0a6h
    2929    2929   0097F                         keepx  bit    0a5h
    2930    2930   0097F                         dmap   bit    0a4h
    2931    2931   0097F                         int_en bit    0a3h
    2932    2932   0097F                         eoc    bit    0a2h
    2933    2933   0097F                         error  bit    0a1h
    2934    2934   0097F                         cd_bsy bit    0a0h
    2935    2935   0097F                  
    2936    2936   0097F                  cd_con        data   0a1h          ;cordic control register           reset=000h
    2937    2937   0097F                  
    2938    2938   0097F                  ;*******************************************************************************
    2939    2939   0097F                  ;
    2940    2940   0097F                  ; wdt registers can be accessed in the mapped memory area (rmap=1)
    2941    2941   0097F                  ;
    2942    2942   0097F                  ;*******************************************************************************
    2943    2943   0097F                  
    2944    2944   0097F                  wdtcon        data   0bbh          ;watchdog timer control            reset=000h
    2945    2945   0097F                  wdtrel        data   0bch          ;watchdog timer reload             reset=000h
    2946    2946   0097F                  wdtwinb       data   0bdh          ;wdt window boundry count          reset=000h
    2947    2947   0097F                  wdtl          data   0beh          ;wdt register low                  reset=000h
    2948    2948   0097F                  wdth          data   0bfh          ;wdt register high                 reset=000h
    2949    2949   0097F                  
    2950    2950   0097F                  ;*******************************************************************************
    2951    2951   0097F                  ;
    2952    2952   0097F                  ; t21 registers can be accessed in the mapped memory area (rmap=1)
    2953    2953   0097F                  ;
    2954    2954   0097F                  ;*******************************************************************************
    2955    2955   0097F                  
    2956    2956   0097F                  t21_t2con     data   0c0h          ;timer 21 control register         reset=000h
    2957    2957   0097F                  ;t2_t2con is bit addressable bits are aalready defined
    2958    2958   0097F                         ;tf2    bit    0c7h
    2959    2959   0097F                         ;exf2   bit    0c6h
    2960    2960   0097F                                                     ;2 bits are not implemented
    2961    2961   0097F                         ;exen2  bit    0c3h
    2962    2962   0097F                         ;tr2    bit    0c2h
    2963    2963   0097F                         ;ct2    bit    0c1h
    2964    2964   0097F                         ;cprl2  bit    0c0h
    2965    2965   0097F                  
    2966    2966   0097F                  t21_t2mod      data   0c1h          ;timer 21 mode register           reset=000h
    2967    2967   0097F                  t21_rc2l       data   0c2h          ;timer 21 rel/cap low             reset=000h
    2968    2968   0097F                  t21_rc2h       data   0c3h          ;timer 21 rel/cap high            reset=000h
    2969    2969   0097F                  t21_t2l        data   0c4h          ;timer 21 register low            reset=000h
    2970    2970   0097F                  t21_t2h        data   0c5h          ;timer 21 register high           reset=000h
    2971    2971   0097F                  
    2972    2972   0097F                  ;*******************************************************************************
    2973    2973   0097F                  ;
    2974    2974   0097F                  ; uart1 registers can be accessed in the mapped memory area (rmap=1)
    2975    2975   0097F                  ;
    2976    2976   0097F                  ;*******************************************************************************
    2977    2977   0097F                  
    2978    2978   0097F                  scon1         data   0c8h          ;sirial channel 1 control          reset=000h
    2979    2979   0097F                  ;s1con is bit addressable
    2980    2980   0097F                         sm01   bit    0cfh
    2981    2981   0097F                         sm11   bit    0ceh
    2982    2982   0097F                         sm21   bit    0cdh
    2983    2983   0097F                         ren1   bit    0cch
    2984    2984   0097F                         tb81   bit    0cbh
    2985    2985   0097F                         rb81   bit    0cah
    2986    2986   0097F                         ti1    bit    0c9h
    2987    2987   0097F                         ri1    bit    0c8h
    2988    2988   0097F                  
    2989    2989   0097F                  sbuf1         data   0c9h          ;serial channel 1 data             reset=000h
    2990    2990   0097F                  bcon1         data   0cah          ;baud rate control register        reset=000h
    2991    2991   0097F                  bg1           data   0cbh          ;baud rate timer reload            reset=000h
    2992    2992   0097F                  fdcon1        data   0cch          ;fractional devider control        reset=000h
    2993    2993   0097F                  fdstep1       data   0cdh          ;fractional devider reload         reset=000h
    2994    2994   0097F                  fdres1        data   0ceh          ;fractional devider result         reset=000h
    2995    2995   0097F                  
    2996    2996   0097F                  ;*******************************************************************************
    2997    2997   0097F                  ;
    2998    2998   0097F                  ; ocds registers can be accessed in mapped memory area (rmap=1)
    2999    2999   0097F                  ;
    3000    3000   0097F                  ;*******************************************************************************
    3001    3001   0097F                  
    3002    3002   0097F                  mmcr2         data   0e9h          ;monitor mode control              reset=01-h
    3003    3003   0097F                  mmcr          data   0f1h          ;monitor control                   reset=000h
    3004    3004   0097F                  mmsr          data   0f2h          ;monitor mode status               reset=000h
    3005    3005   0097F                  mmbpcr        data   0f3h          ;breakpoints control register      reset=000h
    3006    3006   0097F                  mmicr         data   0f4h          ;monitor mode interrupt control    reset=000h
    3007    3007   0097F                  mmdr          data   0f5h          ;monitor mode data transfer        reset=000h
    3008    3008   0097F                  hwbpsr        data   0f6h          ;hardware breakpoints select       reset=000h
    3009    3009   0097F                  hwbpdr        data   0f7h          ;hardware breakpoints data         reset=000h
    3010    3010   0097F                  mmwr1         data   0ebh          ;monitor work register 1           reset=000h
    3011    3011   0097F                  mmwr2         data   0ech          ;monitor work register 2           reset=000h
    3012    3012   0097F                  
    3013    3013   0097F                  ;end directive must be used, but has no signification
    3014    3014   0097F                  
    3015    3015   0097F                  end
    3016    3016   0097F                  
    3017    3017   0097F                  
    3018    3018   0097F                  
    3019    3019   0097F                  
    3020    3020   0097F                  
    3021    3021   0097F                  
    3022    3022   0097F                  
    3023    3023   0097F                  
    3024    3024   0097F                  
    3025    3025   0097F                  
    3026    3026   0097F                  
    3027    3027   0097F                  
    3028    3028   0097F                  
    3029    3029   0097F                  
    3030    3030   0097F                  
    3031    3031   0097F                  
